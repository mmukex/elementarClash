\section{Architektur (Christian Stiens \& Max Meier)}
\label{chap:architektur}

% === ZIELUMFANG: ca. 10 Seiten (Hauptteil) ===
% Pro Pattern: ca. 0.5–1 Seite + UML-Diagramm

ElementarClash setzt 10 GoF-Patterns aus allen drei Kategorien ein.
Tabelle~\ref{tab:pattern-uebersicht} gibt einen Überblick über die gewählten Patterns, ihren konkreten Anwendungsfall im Spiel und die Begründung für die Wahl.
Die anschließenden Abschnitte beschreiben jedes Pattern im Detail.
In den zugehörigen UML-Diagrammen wurde zugunsten der Übersichtlichkeit auf die Darstellung von Packages verzichtet.
Implementieren mehrere konkrete Klassen dasselbe Interface, wird exemplarisch nur eine dargestellt.

\begin{table}[H]
\centering
\small
\begin{tabular}{r l l p{3.5cm} p{4.5cm}}
\toprule
\textbf{\#} & \textbf{Pattern} & \textbf{Kat.} & \textbf{Anwendungsfall} & \textbf{Begründung} \\
\midrule
1 & Factory Method & Erz. & Fraktionsspezifische Einheiten-Erzeugung & 4 Fraktionen $\times$ 3 Typen; erweiterbar ohne Core-Änderungen \\
2 & Builder & Erz. & Schrittweise Spielfeld-Erstellung & 100 Zellen, Geländeverteilung, Spawn-Positionen -- zu komplex für einen Konstruktor \\
3 & Composite & Str. & Battlefield $\to$ Region $\to$ Cell & Einheitliche Operationen auf Einzelzellen und ganzen Regionen \\
4 & Decorator & Str. & Temporäre (De-)Buffs & Stapelbare Laufzeit-Erweiterungen ohne Unterklassen \\
5 & Strategy & Verh. & Bewegung (Boden/Fliegend), Angriff (Nah-/Fernkampf) & Austauschbare Algorithmen pro Einheit \\
6 & State & Verh. & Spielphasen und Einheitenzustände & Zustandsabhängiges Verhalten ohne \texttt{if}-Kaskaden \\
7 & Observer & Verh. & Event-System, UI-Entkopplung & Lose Kopplung zwischen Spiellogik und Darstellung \\
8 & Command & Verh. & MoveCommand, AttackCommand + Undo/Redo & Aktionen als Objekte mit Rollback-Fähigkeit \\
9 & Chain of Resp. & Verh. & Schadensberechnungs-Pipeline & Modulare Handler-Kette für Modifikatoren \\
10 & Visitor & Verh. & Gelände-Effekte auf Einheiten & Double Dispatch für 5 Gelände $\times$ 4 Fraktionen \\
\bottomrule
\end{tabular}
\caption{Übersicht der eingesetzten Design Patterns}
\label{tab:pattern-uebersicht}
\end{table}

\subsection{Programmentwurf (Max Meier)}
\label{sec:programmentwurf}

Die Codebasis ist in fünf Hauptpakete gegliedert, die jeweils eine fachliche Verantwortung kapseln:

\begin{description}
	\item[\texttt{battlefield}]
	Spielfeld-Modell (Composite Pattern): \texttt{Cell}, \texttt{Region}, \texttt{Battlefield} sowie das Unter\-paket \texttt{terraineffect} mit dem Visitor Pattern (\texttt{TerrainVisitor}, fünf konkrete Visitor, \texttt{TerrainVisitorFactory}).

	\item[\texttt{units}]
	Einheiten-Modell: Basisklasse \texttt{Unit}, Fraktions-Enum und die Unter\-pakete \texttt{types} (12~konkrete Einheiten in je einem Fraktionspaket), \texttt{strategy} (Movement-/Attack\-Strategy), \texttt{state} (Unit\-States) sowie \texttt{bonus} mit \texttt{temporary} (Decorator Pattern für Buffs/Debuffs).

	\item[\texttt{game}]
	Spiellogik: \texttt{Game}, \texttt{GameBuilder} (Builder Pattern), \texttt{RoundManager} sowie die Unter\-pakete \texttt{phase} (State Pattern für Spielphasen), \texttt{command} (Command Pattern mit \texttt{CommandExecutor} und \texttt{CommandHistory}), \texttt{combat} mit \texttt{handler} (Chain of Responsibility) und \texttt{event} mit \texttt{observer} (Observer Pattern).

	\item[\texttt{ui}]
	ASCII-Konsolenoberfläche: Rendering des Spielfelds und Verarbeitung der Spielereingaben.

	\item[\texttt{util}]
	Hilfsklassen, u.\,a. \texttt{Position} für Koordinatenberechnungen.
\end{description}

Diese Paketstruktur spiegelt die Trennung von Datenmodell (\texttt{battlefield}, \texttt{units}), Spiellogik (\texttt{game}) und Darstellung (\texttt{ui}) wider.
Jedes der 10~Design Patterns ist in dem Paket verortet, das seine fachliche Domäne repräsentiert -- beispielsweise liegt das Strategy Pattern unter \texttt{units.strategy}, das Visitor Pattern unter \texttt{battlefield.terraineffect} und das Command Pattern unter \texttt{game.command}.

Der \texttt{GameBuilder} (Builder Pattern) erzeugt das \texttt{Battlefield} als Composite-Struktur aus \texttt{Cell}, \texttt{Region} und \texttt{Battlefield}.
Der \texttt{TerrainEffectHandler} in der Schadensberechnungs-Pipeline (Chain of Responsibility) dispatcht für Angreifer und Verteidiger je einen \texttt{TerrainVisitor} auf der aktuellen Zelle des Composite-Spielfelds.
\texttt{MoveCommand} und \texttt{AttackCommand} (Command Pattern) delegieren ihre Validierung an die jeweilige Strategy der Einheit.
Der \texttt{AttackCommand} löst die Handler-Kette des \texttt{DamageCalculator} aus, die Visitor, Decorator und Fraktionsmatrix integriert.
State Pattern und Observer Pattern rahmen den Ablauf ein: Spielphasen steuern den Kontrollfluss, Observer entkoppeln die UI von der Spiellogik.

\subsection{Erzeugungsmuster}
\label{sec:erzeugungsmuster}

\subsubsection{Factory Method (Christian Stiens)}
\label{subsec:factory-method}
% Anwendung: Fraktionsspezifische Einheiten-Erzeugung
% Begründung: 4 Fraktionen × 3 Einheiten, erweiterbar ohne Core-Änderungen
% UML-Diagramm + Code-Beispiel
% Verantwortlich: @crstmkt
Jede der vier Fraktion hat einen Basisstamm von drei Einheitentypen.
Jeder Einheitentyp hat einen Bassissatz an Stats (Lebenspunkte, Angriffspunkte, Verteidigungspunkte etc.).
Um eventuelle zukünftige Erweiterungen ohne Änderungen an der Core Logik zu ermöglichen und um nicht für jeden Einheitentypen den speziellen Kontruktor aufrufen zu müssen wir Factory Method verwedent.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Factory_Method_Pattern___ElementarClash}
	\caption{Factory Method Pattern für die Einheitenerzeugung}
	\label{fig:factory-method}
\end{figure}

\subsubsection{Builder (Max Meier)}
\label{subsec:builder}
% Verantwortlich: @mmukex
Das 10$\times$10-Spielfeld umfasst 100 Zellen mit anteiliger Geländeverteilung (30\,\% Wüste, 20\,\% Wald, 20\,\% Stein, 15\,\% Lava, 15\,\% Eis), Startpositionen für zwei Fraktionen und eine beliebige Anzahl von Einheiten pro Fraktion.
Ein einzelner Konstruktoraufruf ist für diese Komplexität unpraktikabel.
Das Builder Pattern trennt die schrittweise Konfiguration von der eigentlichen Objekterzeugung (vgl. \cite{gof}).

Die Klasse \texttt{GameBuilder} stellt eine Fluent-API bereit: \texttt{withFactions()} registriert Fraktionen, \texttt{withCustomTerrain()} setzt optional eine benutzerdefinierte Geländeverteilung, \texttt{withRandomSeed()} einen Zufalls-Seed.
Einheiten werden per \texttt{addUnit()} einer Fraktion zugewiesen.
Die \texttt{build()}-Methode validiert die Konfiguration (mindestens 2 Fraktionen, jede mit Einheiten), erzeugt das \texttt{Battlefield}, verteilt die Geländetypen nach Prozentverteilung und platziert die Einheiten in zwei gegenüberliegenden Ecken-Spawn-Zonen à 3$\times$3~Felder (vgl. \texttt{GameBuilder.java Z.\,87ff}).
Unterschiedliche Spielkonfigurationen (z.\,B. reine Lava-Karte, symmetrische Wettkampfkarte) lassen sich so mit derselben Builder-Klasse erzeugen.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Builder_Pattern___ElementarClash}
	\caption{Builder Pattern für die Spielerstellung}
	\label{fig:builder-pattern}
\end{figure}

\subsection{Strukturmuster}
\label{sec:strukturmuster}

\subsubsection{Composite (Max Meier)}
\label{subsec:composite}
% Verantwortlich: @mmukex
Das Spielfeld besteht aus 100 einzelnen Zellen, die in Zeilen und beliebigen Teilregionen organisiert sind.
Geländeeffekte und dynamische Ereignisse (z.\,B. Waldbrand, Erdbeben, Geysir) müssen einheitlich auf einzelne Zellen und ganze Regionen anwendbar sein.
Das Composite Pattern definiert dafür eine gemeinsame Schnittstelle für Einzel- und Gruppenobjekte (vgl. \cite{gof}).

Das Interface \texttt{BattlefieldComponent} deklariert \texttt{cells()}, \texttt{getCell(int)} und \texttt{applyEffect(Consumer<Cell>)}.
\texttt{Cell} (Leaf) gibt eine Einelementliste zurück, \texttt{Region} (Composite) delegiert an ihre enthaltenen Zellen.
\texttt{Battlefield} (Root-Composite) organisiert 10~Regionen à 10~Zellen und bietet \texttt{getRegion(x1,\,y1,\,x2,\,y2)} für beliebige Teilbereiche (vgl. \texttt{Battlefield.java Z.\,119ff}).
Events der \texttt{EventPhase} wenden ihre Effekte per \texttt{applyEffect()} auf eine einzelne Zelle, eine 3$\times$3-Region oder das gesamte Spielfeld an -- ohne duplizierte Logik.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Composite_Pattern___ElementarClash}
	\caption{Composite Pattern für die Spielfeld-Hierarchie}
	\label{fig:composite-pattern}
\end{figure}

\subsubsection{Decorator (Christian Stiens)}
\label{subsec:decorator}
% Anwendung: Temporäre Buffs/Debuffs stapeln
% Begründung: Dynamische Erweiterung zur Laufzeit
% UML-Diagramm
% Verantwortlich: @crstmkt
Im Spielverlauf wir mit steigender Rundenzahl die Wahrscheinlichkeit erhöhte, dass während der Eventphase eine zufällig ausgewählte Einheit der aktiven Fraktion einen (von sechs fest definierten) zufällig ausgewählten (De-)Buff erhält.
Dieser (De-)Buff wird per Decorator Pattern an die Unit angeklebt.
Im UI werden diese (De-)Buffs in geschweiften Klammern angezeigt.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Decorator_Pattern___ElementarClash-Decorator_Pattern___ElementarClash_Unit_Buffs_Debuffs__GoF__4__Dynamically_Attaching_Responsibilities}
	\caption{Decorator Pattern für temporäre Buffs und Debuffs}
	\label{fig:decorator-pattern}
\end{figure}

\subsection{Verhaltensmuster}
\label{sec:verhaltensmuster}

\subsubsection{Strategy (Max Meier)}
\label{subsec:strategy}
% Verantwortlich: @mmukex
Einheiten unterschiedlicher Fraktionen besitzen verschiedene Bewegungs- und Angriffsregeln: Luft-Einheiten fliegen über Gelände hinweg, Feuer-Einheiten bewegen sich auf Lava günstiger, Fernkämpfer prüfen Sichtlinien.
Das Strategy Pattern kapselt diese Regeln in austauschbare Algorithmen hinter einem gemeinsamen Interface (vgl. \cite{gof}).

\texttt{MovementStrategy} definiert \texttt{calculateMovementCost(Terrain)} und \texttt{canMoveTo()}.
\texttt{GroundMovementStrategy} berücksichtigt fraktionsspezifische Geländemodifikatoren (z.\,B. Feuer auf Lava: Kosten~1, Wasser auf Lava: Kosten~3), \texttt{FlyingMovementStrategy} setzt alle Kosten pauschal auf~1.
\texttt{AttackStrategy} definiert \texttt{canAttack()}, \texttt{calculateBaseDamage()} und \texttt{getAttackRange()}.
\texttt{MeleeAttackStrategy} prüft die Manhattan-Distanz, \texttt{RangedAttackStrategy} validiert zusätzlich die Sichtlinie und blockiert Angriffe durch Wald-Gelände -- es sei denn, die Einheit besitzt \texttt{ignoresForestDefense} (vgl. \texttt{RangedAttackStrategy.java Z.\,52ff}).
Alle 12 konkreten Einheiten setzen ihre Strategien explizit im Konstruktor: 4~Einheiten erhalten \texttt{FlyingMovementStrategy} (alle Luft-Einheiten und Phönix), 5~Einheiten \texttt{RangedAttackStrategy} (Flammen-Bogenschütze, Frost-Magier, Sturm-Rufer, Himmels-Wächter, Terra-Schamane).
Die Getter in \texttt{Unit} liefern \texttt{GroundMovementStrategy} bzw. \texttt{MeleeAttackStrategy} als Fallback-Default (vgl. \texttt{Unit.java Z.\,142ff}).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Strategy_Pattern___ElementarClash}
	\caption{Strategy Pattern für Bewegung und Angriff}
	\label{fig:strategy-pattern}
\end{figure}

\subsubsection{State (Christian Stiens)}
\label{subsec:state}
% Anwendung: Spielphasen (Setup, Event, InProgress, GameOver)
% Begründung: Zustandsabhängiges Verhalten
% UML-Diagramm
% Verantwortlich: @crstmkt
Spielphasen (SetupPhase, PlayerTurnPhase, EventPhase, GameOverPhase) und UnitStates (Attacking, Moving, Stunned, Idle, Dead) werden über das State Pattern implementiert.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/State_Pattern___ElementarClash-State_Pattern___ElementarClash_Game_Phases__GoF__6__Object_Behavior_Changes_Based_on_Internal_State}
	\caption{State Pattern für Spielphasen und Einheitenzustände}
	\label{fig:state-pattern}
\end{figure}

\subsubsection{Observer (Christian Stiens)}
\label{subsec:observer}
% Anwendung: Event-System (UI-Updates entkoppeln)
% Begründung: Lose Kopplung zwischen Spiellogik und Darstellung
% UML-Diagramm
% Verantwortlich: @crstmkt
Entkopplung von UI-Updates und dynamische Ereignissen.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Observer_Pattern___ElementarClash-Observer_Pattern___ElementarClash_Event_System__GoF__7__One_to_Many_Dependency_for_Event_Notification}
	\caption{Observer Pattern für UI-Updates und Event-System}
	\label{fig:observer-pattern}
\end{figure}

\subsubsection{Command (Max Meier)}
\label{subsec:command}
% Verantwortlich: @mmukex
Pro Runde stehen jeder Einheit zwei Aktionen zur Verfügung: Bewegen und Angreifen.
Der Spieler kann einzelne Aktionen rückgängig machen (Undo) und wiederholen (Redo).
Das Command Pattern kapselt Aktionen als Objekte mit \texttt{execute()}- und \texttt{undo()}-Methoden (vgl. \cite{gof}).

Das Interface \texttt{Command} deklariert \texttt{validate(Game)}, \texttt{execute(Game)} und \texttt{undo(Game)}.
\texttt{MoveCommand} speichert die vorherige Position und stellt sie bei \texttt{undo()} wieder her (vgl. \texttt{MoveCommand.java Z.\,77ff}).
\texttt{AttackCommand} sichert die Lebenspunkte des Ziels, nutzt den \texttt{DamageCalculator} (Chain of Responsibility, vgl. Abschnitt~\ref{subsec:chain}) und heilt das Ziel bei \texttt{undo()} auf den gespeicherten Wert zurück (vgl. \texttt{AttackCommand.java Z.\,86ff}).
Die \texttt{CommandHistory} verwaltet zwei Stacks (\texttt{executedCommands} für Undo, \texttt{undoneCommands} für Redo); \texttt{push()} leert den Redo-Stack, da ein neuer Befehl die Redo-Verzweigung verwirft (vgl. \texttt{CommandHistory.java Z.\,32ff}).
Der \texttt{CommandExecutor} validiert den Befehl, führt ihn aus und protokolliert ihn in der Historie (vgl. \texttt{CommandExecutor.java Z.\,22ff}).
Bei Rundenwechsel leert \texttt{clearHistory()} beide Stacks (Per-Turn-Rollback).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Command_Pattern___ElementarClash}
	\caption{Command Pattern für Undo/Redo}
	\label{fig:command-pattern}
\end{figure}

\subsubsection{Chain of Responsibility (Christian Stiens)}
\label{subsec:chain}
% Anwendung: Schadensberechnung-Pipeline
% Begründung: Modulare Handler-Kette für Modifikatoren
% UML-Diagramm
% Verantwortlich: @crstmkt
Basisschaden, Fraktionseffekte, Terraineffekte, (temporäre) Effekte auf einer Einheit addieren sich zu einem Gesamtschaden, den die Einheit erleidet.


\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Chain_of_Responsibility_Pattern___ElementarClash-Chain_of_Responsibility_Pattern___ElementarClash_Damage_Pipeline__GoF__9__Decoupled_Request_Processing_Through_Handler_Chain}
	\caption{Chain of Responsibility Pattern für modulare Schadensberechnung}
	\label{fig:chain-of-responsibility}
\end{figure}

\subsubsection{Visitor (Max Meier)}
\label{subsec:visitor}
% Verantwortlich: @mmukex
Jeder der fünf Geländetypen wirkt sich unterschiedlich auf die vier Fraktionen aus: Feuer-Einheiten erhalten auf Lava +2~Angriff, Wasser-Einheiten erleiden dort $-5$~LP/Runde, Erde und Luft bleiben unberührt.
20~Kombinationen (5~Gelände $\times$ 4~Fraktionen) direkt über \texttt{if}-Anweisungen zu modellieren wäre bei neuen Geländetypen fehleranfällig.
Das Visitor Pattern nutzt Double Dispatch, um beide Dimensionen (Gelände und Fraktion) ohne Fallunterscheidungen aufzulösen (vgl. \cite{gof}).

\texttt{TerrainVisitor} deklariert je eine Methode pro Fraktion: \texttt{visitFireUnit()}, \texttt{visitWaterUnit()}, \texttt{visitEarthUnit()}, \texttt{visitAirUnit()}.
\texttt{AbstractTerrainVisitor} liefert als Standard \texttt{TerrainEffectResult.NEUTRAL} und stellt Hilfsmethoden (\texttt{createAttackBonus()}, \texttt{createDefenseBonus()} etc.) bereit.
Fünf konkrete Visitor -- \texttt{LavaTerrainVisitor}, \texttt{IceTerrainVisitor}, \texttt{ForestTerrainVisitor}, \texttt{StoneTerrainVisitor}, \texttt{DesertTerrainVisitor} -- überschreiben nur die Methoden mit tatsächlichen Effekten.
\texttt{Unit.accept(TerrainVisitor)} realisiert den Double Dispatch per \texttt{switch} über die Fraktion (vgl. \texttt{Unit.java Z.\,168ff}).
Die \texttt{TerrainVisitorFactory} cached die fünf zustandslosen Visitor-Instanzen in einer \texttt{EnumMap} und liefert sie per \texttt{getVisitor(Terrain)} in $O(1)$ aus (vgl. \texttt{TerrainVisitorFactory.java Z.\,36ff}).
Das Ergebnis ist ein unveränderliches \texttt{TerrainEffectResult}-Record mit Angriffs-/Verteidigungsbonus, LP-pro-Runde-Effekt und optionaler Geländetransformation (z.\,B. Eis $\to$ Wüste bei Feuer-Einheiten).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Visitor_Pattern___ElementarClash}
	\caption{Visitor Pattern für Geländeeffekte}
	\label{fig:visitor-pattern}
\end{figure}
