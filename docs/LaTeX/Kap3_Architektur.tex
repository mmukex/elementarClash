\section{Architektur (Christian Stiens \& Max Meier)}
\label{chap:architektur}

% === ZIELUMFANG: ca. 10 Seiten (Hauptteil) ===
% Pro Pattern: ca. 0.5–1 Seite + UML-Diagramm

ElementarClash setzt 10 GoF-Patterns aus allen drei Kategorien ein.
Tabelle~\ref{tab:pattern-uebersicht} gibt einen Überblick über die gewählten Patterns, ihren konkreten Anwendungsfall im Spiel und die Begründung für die Wahl.
Die anschließenden Abschnitte beschreiben jedes Pattern im Detail.
In den zugehörigen UML-Diagrammen wurde zugunsten der Übersichtlichkeit auf die Darstellung von Packages verzichtet.
Implementieren mehrere konkrete Klassen dasselbe Interface, wird exemplarisch nur eine dargestellt.

\begin{table}[H]
\centering
\small
\begin{tabular}{r l l p{3.5cm} p{4.5cm}}
\toprule
\textbf{\#} & \textbf{Pattern} & \textbf{Kat.} & \textbf{Anwendungsfall} & \textbf{Begründung} \\
\midrule
1 & Factory Method & Erz. & Fraktionsspezifische Einheiten-Erzeugung & 4 Fraktionen $\times$ 3 Typen; erweiterbar ohne Core-Änderungen \\
2 & Builder & Erz. & Schrittweise Spielfeld-Erstellung & 100 Zellen, Geländeverteilung, Spawn-Positionen -- zu komplex für einen Konstruktor \\
3 & Composite & Str. & Battlefield $\to$ Region $\to$ Cell & Einheitliche Operationen auf Einzelzellen und ganzen Regionen \\
4 & Decorator & Str. & Temporäre (De-)Buffs & Stapelbare Laufzeit-Erweiterungen ohne Unterklassen \\
5 & Strategy & Verh. & Bewegung (Boden/Fliegend), Angriff (Nah-/Fernkampf) & Austauschbare Algorithmen pro Einheit \\
6 & State & Verh. & Spielphasen und Einheitenzustände & Zustandsabhängiges Verhalten ohne \texttt{if}-Kaskaden \\
7 & Observer & Verh. & Event-System, UI-Entkopplung & Lose Kopplung zwischen Spiellogik und Darstellung \\
8 & Command & Verh. & MoveCommand, AttackCommand + Undo/Redo & Aktionen als Objekte mit Rollback-Fähigkeit \\
9 & Chain of Resp. & Verh. & Schadensberechnungs-Pipeline & Modulare Handler-Kette für Modifikatoren \\
10 & Visitor & Verh. & Gelände-Effekte auf Einheiten & Double Dispatch für 5 Gelände $\times$ 4 Fraktionen \\
\bottomrule
\end{tabular}
\caption{Übersicht der eingesetzten Design Patterns}
\label{tab:pattern-uebersicht}
\end{table}

\subsection{Programmentwurf (Max Meier)}
\label{sec:programmentwurf}

Die Codebasis ist in fünf Hauptpakete gegliedert, die jeweils eine fachliche Verantwortung kapseln:

\begin{description}
	\item[\texttt{battlefield}]
	Spielfeld-Modell (Composite Pattern): \texttt{Cell}, \texttt{Region}, \texttt{Battlefield} sowie das Unter\-paket \texttt{terraineffect} mit dem Visitor Pattern (\texttt{TerrainVisitor}, fünf konkrete Visitor, \texttt{TerrainVisitorFactory}).

	\item[\texttt{units}]
	Einheiten-Modell: Basisklasse \texttt{Unit}, Fraktions-Enum und die Unter\-pakete \texttt{types} (12~konkrete Einheiten in je einem Fraktionspaket), \texttt{strategy} (Movement-/Attack\-Strategy), \texttt{state} (Unit\-States) sowie \texttt{bonus} mit \texttt{temporary} (Decorator Pattern für Buffs/Debuffs).

	\item[\texttt{game}]
	Spiellogik: \texttt{Game}, \texttt{GameBuilder} (Builder Pattern), \texttt{RoundManager} sowie die Unter\-pakete \texttt{phase} (State Pattern für Spielphasen), \texttt{command} (Command Pattern mit \texttt{CommandExecutor} und \texttt{CommandHistory}), \texttt{combat} mit \texttt{handler} (Chain of Responsibility) und \texttt{event} mit \texttt{observer} (Observer Pattern).

	\item[\texttt{ui}]
	ASCII-Konsolenoberfläche: Rendering des Spielfelds und Verarbeitung der Spielereingaben.

	\item[\texttt{util}]
	Hilfsklassen, u.\,a. \texttt{Position} für Koordinatenberechnungen.
\end{description}

Diese Paketstruktur spiegelt die Trennung von Datenmodell (\texttt{battlefield}, \texttt{units}), Spiellogik (\texttt{game}) und Darstellung (\texttt{ui}) wider.
Jedes der 10~Design Patterns ist in dem Paket verortet, das seine fachliche Domäne repräsentiert -- beispielsweise liegt das Strategy Pattern unter \texttt{units.strategy}, das Visitor Pattern unter \texttt{battlefield.terraineffect} und das Command Pattern unter \texttt{game.command}.

Der \texttt{GameBuilder} (Builder Pattern) erzeugt das \texttt{Battlefield} als Composite-Struktur aus \texttt{Cell}, \texttt{Region} und \texttt{Battlefield}.
Der \texttt{TerrainEffectHandler} in der Schadensberechnungs-Pipeline (Chain of Responsibility) dispatcht für Angreifer und Verteidiger je einen \texttt{TerrainVisitor} auf der aktuellen Zelle des Composite-Spielfelds.
\texttt{MoveCommand} und \texttt{AttackCommand} (Command Pattern) delegieren ihre Validierung an die jeweilige Strategy der Einheit.
Der \texttt{AttackCommand} löst die Handler-Kette des \texttt{DamageCalculator} aus, die Visitor, Decorator und Fraktionsmatrix integriert.
State Pattern und Observer Pattern rahmen den Ablauf ein: Spielphasen steuern den Kontrollfluss, Observer entkoppeln die UI von der Spiellogik.

\subsection{Erzeugungsmuster}
\label{sec:erzeugungsmuster}

\subsubsection{Factory Method (Christian Stiens)}
\label{subsec:factory-method}
% Anwendung: Fraktionsspezifische Einheiten-Erzeugung
% Begründung: 4 Fraktionen × 3 Einheiten, erweiterbar ohne Core-Änderungen
% UML-Diagramm + Code-Beispiel
% Verantwortlich: @crstmkt
ElementarClash umfasst 12 konkrete Einheitenklassen in vier Fraktionen mit je eigenen Stat-Werten (vgl. Kapitel 2.3.1).
Ohne ein Erzeugungsmuster müsste der Aufrufer jeden konkreten Konstruktor kennen und die passenden Stat-Werte selbst übergeben -- eine Kopplung, die bei einer neuen Fraktion Änderungen an mehreren Stellen im Code erfordern würde.

Das Factory Method Pattern löst dieses Problem durch eine zweistufige Hierarchie.
Die abstrakte Klasse \texttt{UnitFactory} definiert \texttt{createUnit(UnitType)} als finalen Template-Method-Einstiegspunkt: Sie validiert, ob der angeforderte \texttt{UnitType} zur Fraktion gehört, generiert eine eindeutige Einheiten-ID im Format \texttt{F1}, \texttt{W2} usw. (Anfangsbuchstabe der Fraktion + laufender Zähler) und delegiert die eigentliche Objekterzeugung an die abstrakte Factory Method \texttt{createUnitInternal(id, type)}.
Jede der vier konkreten Fabriken -- \texttt{FireUnitFactory}, \texttt{WaterUnitFactory}, \texttt{EarthUnitFactory} und \texttt{AirUnitFactory} -- implementiert \texttt{createUnitInternal()} als \texttt{switch}-Ausdruck über den \texttt{UnitType} und instanziiert die zugehörige Einheitenklasse mit den hart codierten Stat-Werten (vgl. \texttt{FireUnitFactory.java}).
Die konkreten Einheitenklassen sind package-private, sodass sie ausschließlich über ihre Fabrik instanziiert werden können -- eine durch die Paketstruktur erzwungene Kapselung. (vgl. \cite{entwurfsmuster})

Das Ergebnis: Das Hinzufügen einer neuen Fraktion erfordert lediglich eine neue Fabrik und die zugehörigen Einheitenklassen im gleichen Paket.
Die restliche Spiellogik -- \texttt{GameBuilder}, \texttt{Game}, \texttt{DamageCalculator} -- bleibt unverändert und arbeitet ausschließlich gegen die abstrakte \texttt{UnitFactory} und \texttt{Unit}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Factory_Method_Pattern___ElementarClash}
	\caption{Factory Method Pattern für die Einheitenerzeugung}
	\label{fig:factory-method}
\end{figure}

\subsubsection{Builder (Max Meier)}
\label{subsec:builder}
% Verantwortlich: @mmukex
Das 10$\times$10-Spielfeld umfasst 100 Zellen mit anteiliger Geländeverteilung (30\,\% Wüste, 20\,\% Wald, 20\,\% Stein, 15\,\% Lava, 15\,\% Eis), Startpositionen für zwei Fraktionen und eine beliebige Anzahl von Einheiten pro Fraktion.
Ein einzelner Konstruktoraufruf ist für diese Komplexität unpraktikabel.
Das Builder Pattern trennt die schrittweise Konfiguration von der eigentlichen Objekterzeugung (vgl. \cite{gof}).

Die Klasse \texttt{GameBuilder} stellt eine Fluent-API bereit: \texttt{withFactions()} registriert Fraktionen, \texttt{withCustomTerrain()} setzt optional eine benutzerdefinierte Geländeverteilung, \texttt{withRandomSeed()} einen Zufalls-Seed.
Einheiten werden per \texttt{addUnit()} einer Fraktion zugewiesen.
Die \texttt{build()}-Methode validiert die Konfiguration (mindestens 2 Fraktionen, jede mit Einheiten), erzeugt das \texttt{Battlefield}, verteilt die Geländetypen nach Prozentverteilung und platziert die Einheiten in zwei gegenüberliegenden Ecken-Spawn-Zonen à 3$\times$3~Felder (vgl. \texttt{GameBuilder.java Z.\,87ff}).
Unterschiedliche Spielkonfigurationen (z.\,B. reine Lava-Karte, symmetrische Wettkampfkarte) lassen sich so mit derselben Builder-Klasse erzeugen.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Builder_Pattern___ElementarClash}
	\caption{Builder Pattern für die Spielerstellung}
	\label{fig:builder-pattern}
\end{figure}

\subsection{Strukturmuster}
\label{sec:strukturmuster}

\subsubsection{Composite (Max Meier)}
\label{subsec:composite}
% Verantwortlich: @mmukex
Das Spielfeld besteht aus 100 einzelnen Zellen, die in Zeilen und beliebigen Teilregionen organisiert sind.
Geländeeffekte und dynamische Ereignisse (z.\,B. Waldbrand, Erdbeben, Geysir) müssen einheitlich auf einzelne Zellen und ganze Regionen anwendbar sein.
Das Composite Pattern definiert dafür eine gemeinsame Schnittstelle für Einzel- und Gruppenobjekte (vgl. \cite{gof}).

Das Interface \texttt{BattlefieldComponent} deklariert \texttt{cells()}, \texttt{getCell(int)} und \texttt{applyEffect(Consumer<Cell>)}.
\texttt{Cell} (Leaf) gibt eine Einelementliste zurück, \texttt{Region} (Composite) delegiert an ihre enthaltenen Zellen.
\texttt{Battlefield} (Root-Composite) organisiert 10~Regionen à 10~Zellen und bietet \texttt{getRegion(x1,\,y1,\,x2,\,y2)} für beliebige Teilbereiche (vgl. \texttt{Battlefield.java Z.\,119ff}).
Events der \texttt{EventPhase} wenden ihre Effekte per \texttt{applyEffect()} auf eine einzelne Zelle, eine 3$\times$3-Region oder das gesamte Spielfeld an -- ohne duplizierte Logik.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Composite_Pattern___ElementarClash}
	\caption{Composite Pattern für die Spielfeld-Hierarchie}
	\label{fig:composite-pattern}
\end{figure}

\subsubsection{Decorator (Christian Stiens)}
\label{subsec:decorator}
% Anwendung: Temporäre Buffs/Debuffs stapeln
% Begründung: Dynamische Erweiterung zur Laufzeit
% UML-Diagramm
% Verantwortlich: @crstmkt
Einheiten können zur Laufzeit eine beliebige Kombination aus Angriffs-, Verteidigungs- und Bewegungsboni erhalten, die aus unterschiedlichen Quellen stammen: dem Geländeeffekt des Feldes, dem Fraktions-Synergiebonus sowie zufälligen Ereignissen.
Eine Vererbungshierarchie für alle denkbaren Kombinationen wäre kombinatorisch nicht handhabbar.
Das Decorator Pattern ermöglicht es stattdessen, Boni und Mali zur Laufzeit dynamisch zu stapeln, ohne die \texttt{Unit}-Klasse zu verändern (vgl. \cite{entwurfsmuster}).

Die abstrakte Klasse \texttt{UnitDecorator} definiert die Methoden \texttt{getAttackBonus()}, \texttt{getDefenseBonus()} und \texttt{getMovementBonus()}, die jeweils die \texttt{Unit}-Instanz erhalten, sowie \texttt{tick()} für den Rundenablauf und \texttt{isExpired()} zur Lebenszeit-Überprüfung.
\texttt{Unit} hält eine \texttt{List\allowbreak<UnitDecorator>} und integriert die Boni transparent in seine Getter: \texttt{getAttack()} summiert \texttt{baseStats.attack()} mit dem \texttt{getAttackBonus()} aller nicht abgelaufenen Dekoratoren; analog für Verteidigung und Bewegung (Minimum~1).

Es gibt zwei Decorator-Arten: \texttt{SynergyBonus} ist permanent (isExpired() gibt stets \texttt{false} zurück) und berechnet den Bonus dynamisch anhand benachbarter Verbündeter -- beim Bewegen wird er entfernt und neu hinzugefügt.
Die sechs temporären Dekoratoren laufen nach zwei Runden ab: \texttt{AttackBuffDecorator} (+2~ATK), \texttt{AttackDebuffDecorator} ($-2$~ATK), \texttt{DefenseBuffDecorator} (+2~DEF), \texttt{DefenseDebuffDecorator} ($-2$~DEF), \texttt{HastenedDecorator} (+1~MOV) und \texttt{SlowedDecorator} ($-1$~MOV).
Der \texttt{BuffDebuffManager} wählt zu Beginn jedes Spielerzugs per Zufall eine lebende Einheit der aktiven Fraktion aus und wendet mit rundenweise steigender Wahrscheinlichkeit (Formel: $p = \min(0{,}60,\ 0{,}03 + (r-1) \cdot 0{,}06)$) einen zufälligen Effekt aus dem Buff- oder Debuff-Pool an.
Im UI werden aktive Effekte in geschweiften Klammern hinter dem Einheitennamen angezeigt.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Decorator_Pattern___ElementarClash-Decorator_Pattern___ElementarClash_Unit_Buffs_Debuffs__GoF__4__Dynamically_Attaching_Responsibilities}
	\caption{Decorator Pattern für temporäre Buffs und Debuffs}
	\label{fig:decorator-pattern}
\end{figure}

\subsection{Verhaltensmuster}
\label{sec:verhaltensmuster}

\subsubsection{Strategy (Max Meier)}
\label{subsec:strategy}
% Verantwortlich: @mmukex
Einheiten unterschiedlicher Fraktionen besitzen verschiedene Bewegungs- und Angriffsregeln: Luft-Einheiten fliegen über Gelände hinweg, Feuer-Einheiten bewegen sich auf Lava günstiger, Fernkämpfer prüfen Sichtlinien.
Das Strategy Pattern kapselt diese Regeln in austauschbare Algorithmen hinter einem gemeinsamen Interface (vgl. \cite{gof}).

\texttt{MovementStrategy} definiert \texttt{calculateMovementCost(Terrain)} und \texttt{canMoveTo()}.
\texttt{GroundMovementStrategy} berücksichtigt fraktionsspezifische Geländemodifikatoren (z.\,B. Feuer auf Lava: Kosten~1, Wasser auf Lava: Kosten~3), \texttt{FlyingMovementStrategy} setzt alle Kosten pauschal auf~1.
\texttt{AttackStrategy} definiert \texttt{canAttack()}, \texttt{calculateBaseDamage()} und \texttt{getAttackRange()}.
\texttt{MeleeAttackStrategy} prüft die Manhattan-Distanz, \texttt{RangedAttackStrategy} validiert zusätzlich die Sichtlinie und blockiert Angriffe durch Wald-Gelände -- es sei denn, die Einheit besitzt \texttt{ignoresForestDefense} (vgl. \texttt{RangedAttackStrategy.java Z.\,52ff}).
Alle 12 konkreten Einheiten setzen ihre Strategien explizit im Konstruktor: 4~Einheiten erhalten \texttt{FlyingMovementStrategy} (alle Luft-Einheiten und Phönix), 5~Einheiten \texttt{RangedAttackStrategy} (Flammen-Bogenschütze, Frost-Magier, Sturm-Rufer, Himmels-Wächter, Terra-Schamane).
Die Getter in \texttt{Unit} liefern \texttt{GroundMovementStrategy} bzw. \texttt{MeleeAttackStrategy} als Fallback-Default (vgl. \texttt{Unit.java Z.\,142ff}).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Strategy_Pattern___ElementarClash}
	\caption{Strategy Pattern für Bewegung und Angriff}
	\label{fig:strategy-pattern}
\end{figure}

\subsubsection{State (Christian Stiens)}
\label{subsec:state}
% Anwendung: Spielphasen (Setup, Event, InProgress, GameOver)
% Begründung: Zustandsabhängiges Verhalten
% UML-Diagramm
% Verantwortlich: @crstmkt
ElementarClash besitzt einen klar definierten Spielablauf aus vier Phasen, in denen jeweils unterschiedliche Aktionen erlaubt sind.
Ohne ein Zustandsmuster müsste die \texttt{Game}-Klasse bei jedem \texttt{executeCommand()}-Aufruf prüfen, welche Phase gerade aktiv ist -- was zu langen \texttt{if}-Kaskaden führt, die bei jeder neuen Phase erweitert werden müssen.
Das State Pattern verlagert das phasenspezifische Verhalten in separate Klassen und hält \texttt{Game} schlank (vgl. \cite{entwurfsmuster}).

Das Interface \texttt{GamePhaseState} deklariert \texttt{canExecuteCommand()}, \texttt{onEnter()}, \texttt{onExit()} sowie drei \texttt{transitionTo...()}-Methoden.
\texttt{Game.transitionToPhase(newPhase)} ruft \texttt{currentPhase.onExit(this)}, setzt die neue Phase und ruft \texttt{newPhase.onEnter(this)} auf -- der Phasenwechsel ist damit zuverlässig in einer einzigen Methode gekapselt.

Die vier konkreten Phasen sind:
\texttt{SetupPhase} (Singleton) blockiert alle Befehle und wird während der Spielaufbauphase im \texttt{GameBuilder} durchlaufen;
\texttt{PlayerTurnPhase} (Record mit \texttt{activeFaction}) aktiviert in \texttt{onEnter()} den \texttt{BuffDebuffManager} und setzt die Aktionszähler aller Einheiten der aktiven Fraktion zurück -- \texttt{canExecuteCommand()} delegiert die Validierung an \texttt{command.validate(game)};
\texttt{EventPhase} (Singleton) blockiert Befehle und feuert in \texttt{onEnter()} ein zufälliges Ereignis (Waldbrand, Geysir oder Erdbeben), bevor automatisch in die nächste \texttt{PlayerTurnPhase} gewechselt wird;
\texttt{GameOverPhase} (Record mit \texttt{winner}) ist der Terminalzustand -- alle Übergangsmethoden geben \texttt{this} zurück.

Zusätzlich modelliert das State Pattern die Einheitenzustände: \texttt{UnitState} mit den konkreten Zuständen \texttt{IdleState}, \texttt{MovingState}, \texttt{AttackingState}, \texttt{StunnedState} und \texttt{DeadState}.
Diese steuern, welche Aktionen eine Einheit innerhalb eines Spielerzugs noch ausführen darf.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/State_Pattern___ElementarClash-State_Pattern___ElementarClash_Game_Phases__GoF__6__Object_Behavior_Changes_Based_on_Internal_State}
	\caption{State Pattern für Spielphasen und Einheitenzustände}
	\label{fig:state-pattern}
\end{figure}

\subsubsection{Observer (Christian Stiens)}
\label{subsec:observer}
% Anwendung: Event-System (UI-Updates entkoppeln)
% Begründung: Lose Kopplung zwischen Spiellogik und Darstellung
% UML-Diagramm
% Verantwortlich: @crstmkt
Die Spiellogik in \texttt{Game} erzeugt Ereignisse -- Einheiten bewegen sich, greifen an, sterben, Gelände verändert sich -- die sofort in der Konsole dargestellt und gleichzeitig für eine spätere Protokollausgabe aufgezeichnet werden sollen.
Eine direkte Kopplung von \texttt{Game} an den \texttt{ConsoleGameRenderer} würde bedeuten, dass jede neue Ausgabeart (z.\,B. eine grafische Oberfläche oder ein Netzwerk-Log) Änderungen in der Spiellogik erfordert.
Das Observer Pattern löst dies durch eine lose Kopplung: \texttt{Game} kennt nur das Interface \texttt{GameObserver}, nicht seine konkreten Implementierungen (vgl. \cite{gof}).

\texttt{GameObserver} deklariert eine einzige Methode \texttt{onEvent(GameEvent)}.
\texttt{GameEvent} ist eine abstrakte Klasse mit \texttt{getEventType()} und \texttt{getDescription()}; acht konkrete Ereignisklassen decken alle spielrelevanten Übergänge ab: \texttt{GameStartedEvent}, \texttt{TurnStartedEvent}, \texttt{TurnEndedEvent}, \texttt{UnitMovedEvent}, \texttt{UnitAttackedEvent} (mit vollständigem \texttt{DamageResult}), \texttt{UnitDeathEvent}, \texttt{TerrainChangedEvent} und \texttt{GameOverEvent}.

\texttt{Game} hält eine \texttt{List\allowbreak<GameObserver>} und benachrichtigt alle registrierten Observer per \texttt{notifyObservers(event)} an klar definierten Punkten: in \texttt{startGame()}, \texttt{endTurn()}, \texttt{moveUnitInternal()}, \texttt{handleUnitDeath()} sowie im \texttt{AttackCommand} und im \texttt{Battlefield} bei Geländeänderungen.
Zwei konkrete Observer sind registriert: \texttt{ConsoleGameRenderer} verarbeitet jedes Ereignis in einer \texttt{switch}-Verzweigung und gibt es formatiert auf der Konsole aus; \texttt{EventLogObserver} sammelt alle Ereignisse in einer Liste, die am Spielende auf Wunsch vollständig ausgegeben werden kann.
Beide Observer werden im \texttt{GameController}-Konstruktor per \texttt{game.addObserver()} registriert, ohne dass \texttt{Game} dafür angepasst werden muss.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Observer_Pattern___ElementarClash-Observer_Pattern___ElementarClash_Event_System__GoF__7__One_to_Many_Dependency_for_Event_Notification}
	\caption{Observer Pattern für UI-Updates und Event-System}
	\label{fig:observer-pattern}
\end{figure}

\subsubsection{Command (Max Meier)}
\label{subsec:command}
% Verantwortlich: @mmukex
Pro Runde stehen jeder Einheit zwei Aktionen zur Verfügung: Bewegen und Angreifen.
Der Spieler kann einzelne Aktionen rückgängig machen (Undo) und wiederholen (Redo).
Das Command Pattern kapselt Aktionen als Objekte mit \texttt{execute()}- und \texttt{undo()}-Methoden (vgl. \cite{gof}).

Das Interface \texttt{Command} deklariert \texttt{validate(Game)}, \texttt{execute(Game)} und \texttt{undo(Game)}.
\texttt{MoveCommand} speichert die vorherige Position und stellt sie bei \texttt{undo()} wieder her (vgl. \texttt{MoveCommand.java Z.\,77ff}).
\texttt{AttackCommand} sichert die Lebenspunkte des Ziels, nutzt den \texttt{DamageCalculator} (Chain of Responsibility, vgl. Abschnitt~\ref{subsec:chain}) und heilt das Ziel bei \texttt{undo()} auf den gespeicherten Wert zurück (vgl. \texttt{AttackCommand.java Z.\,86ff}).
Die \texttt{CommandHistory} verwaltet zwei Stacks (\texttt{executedCommands} für Undo, \texttt{undoneCommands} für Redo); \texttt{push()} leert den Redo-Stack, da ein neuer Befehl die Redo-Verzweigung verwirft (vgl. \texttt{CommandHistory.java Z.\,32ff}).
Der \texttt{CommandExecutor} validiert den Befehl, führt ihn aus und protokolliert ihn in der Historie (vgl. \texttt{CommandExecutor.java Z.\,22ff}).
Bei Rundenwechsel leert \texttt{clearHistory()} beide Stacks (Per-Turn-Rollback).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Command_Pattern___ElementarClash}
	\caption{Command Pattern für Undo/Redo}
	\label{fig:command-pattern}
\end{figure}

\subsubsection{Chain of Responsibility (Christian Stiens)}
\label{subsec:chain}
% Anwendung: Schadensberechnung-Pipeline
% Begründung: Modulare Handler-Kette für Modifikatoren
% UML-Diagramm
% Verantwortlich: @crstmkt
Jeder Angriff in ElementarClash berücksichtigt mehrere unabhängige Schadensmodifikatoren: den strategiespezifischen Grundschaden, fraktionsbasierte Stärke- und Schwächerelationen, Geländeboni für Angreifer und Verteidiger sowie aktive Dekoratoren der angreifenden Einheit.
Diese Modifikatoren in einer einzelnen Methode zu berechnen würde eine enge Kopplung aller beteiligten Systeme erzeugen; jeder neue Modifikator (z.\,B. ein Wettereffekt) würde Änderungen an zentralem Code erfordern.
Das Chain of Responsibility Pattern kapselt jeden Modifikator in einem eigenen Handler und ermöglicht so eine erweiterbare, modulare Pipeline (vgl. \cite{entwurfsmuster}).

Die abstrakte Basisklasse \texttt{DamageHandler} hält eine Referenz auf den nächsten Handler und implementiert \texttt{handle()} so, dass Subklassen ihre Logik ausführen und dann \texttt{super.handle(context)} aufrufen, um die Kette fortzuführen.
Alle Handler lesen und schreiben auf einem gemeinsamen \texttt{DamageContext}-Objekt, das Angreifer, Verteidiger, Spielzustand und alle Zwischenergebnisse kapselt.
Die Kette wird einmalig im Konstruktor von \texttt{DamageCalculator} über fluente \texttt{setNext()}-Aufrufe aufgebaut und mit \texttt{handlerChain.handle(context)} gestartet.

Die fünf Handler in ihrer festen Reihenfolge:
\textbf{(1)} \texttt{BaseDamageHandler} liest den Grundschaden über das Strategy Pattern (\texttt{attacker.getAttackStrategy().calculateBaseDamage()}) aus.
\textbf{(2)} \texttt{FactionAdvantageHandler} schlägt Angreifer- und Verteidigerfraktion in einer statischen Korrelationsmatrix nach und multipliziert den Schaden mit $\times 1{,}25$ (Vorteil), $\times 0{,}75$ (Nachteil) oder $\times 1{,}0$ (neutral) (vgl. Tabelle 4).
\textbf{(3)} \texttt{TerrainEffectHandler} integriert das Visitor Pattern: Für Angreifer und Verteidiger wird je ein \texttt{TerrainVisitor} auf der aktuellen Zelle dispatcht und die Boni in den Kontext geschrieben.
\textbf{(4)} \texttt{SynergyBonusHandler} integriert das Decorator Pattern: er summiert \texttt{getAttackBonus()} aller nicht abgelaufenen Dekoratoren der angreifenden Einheit.
\textbf{(5)} \texttt{DefenseCalculationHandler} ist der terminale Handler und berechnet den Endschaden nach $\text{finalDamage} = \max(1,\ \text{totalAttack} - \text{totalDefense})$ -- ein Minimalschaden von~1 ist garantiert.
Das fertige Ergebnis wird als unveränderliches \texttt{DamageResult}-Record an den \texttt{AttackCommand} zurückgegeben.


\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/Chain_of_Responsibility_Pattern___ElementarClash-Chain_of_Responsibility_Pattern___ElementarClash_Damage_Pipeline__GoF__9__Decoupled_Request_Processing_Through_Handler_Chain}
	\caption{Chain of Responsibility Pattern für modulare Schadensberechnung}
	\label{fig:chain-of-responsibility}
\end{figure}

\subsubsection{Visitor (Max Meier)}
\label{subsec:visitor}
% Verantwortlich: @mmukex
Jeder der fünf Geländetypen wirkt sich unterschiedlich auf die vier Fraktionen aus: Feuer-Einheiten erhalten auf Lava +2~Angriff, Wasser-Einheiten erleiden dort $-5$~LP/Runde, Erde und Luft bleiben unberührt.
20~Kombinationen (5~Gelände $\times$ 4~Fraktionen) direkt über \texttt{if}-Anweisungen zu modellieren wäre bei neuen Geländetypen fehleranfällig.
Das Visitor Pattern nutzt Double Dispatch, um beide Dimensionen (Gelände und Fraktion) ohne Fallunterscheidungen aufzulösen (vgl. \cite{gof}).

\texttt{TerrainVisitor} deklariert je eine Methode pro Fraktion: \texttt{visitFireUnit()}, \texttt{visitWaterUnit()}, \texttt{visitEarthUnit()}, \texttt{visitAirUnit()}.
\texttt{AbstractTerrainVisitor} liefert als Standard \texttt{TerrainEffectResult.NEUTRAL} und stellt Hilfsmethoden (\texttt{createAttackBonus()}, \texttt{createDefenseBonus()} etc.) bereit.
Fünf konkrete Visitor -- \texttt{LavaTerrainVisitor}, \texttt{IceTerrainVisitor}, \texttt{ForestTerrainVisitor}, \texttt{StoneTerrainVisitor}, \texttt{DesertTerrainVisitor} -- überschreiben nur die Methoden mit tatsächlichen Effekten.
\texttt{Unit.accept(TerrainVisitor)} realisiert den Double Dispatch per \texttt{switch} über die Fraktion (vgl. \texttt{Unit.java Z.\,168ff}).
Die \texttt{TerrainVisitorFactory} cached die fünf zustandslosen Visitor-Instanzen in einer \texttt{EnumMap} und liefert sie per \texttt{getVisitor(Terrain)} in $O(1)$ aus (vgl. \texttt{TerrainVisitorFactory.java Z.\,36ff}).
Das Ergebnis ist ein unveränderliches \texttt{TerrainEffectResult}-Record mit Angriffs-/Verteidigungsbonus, LP-pro-Runde-Effekt und optionaler Geländetransformation (z.\,B. Eis $\to$ Wüste bei Feuer-Einheiten).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{images/Visitor_Pattern___ElementarClash}
	\caption{Visitor Pattern für Geländeeffekte}
	\label{fig:visitor-pattern}
\end{figure}
