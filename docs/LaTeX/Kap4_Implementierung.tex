\section{Implementierung}
\label{chap:implementierung}

% === ZIELUMFANG: ca. 4 Seiten ===

\subsection{Spielobjekte}
\label{sec:spielobjekte}

\subsubsection{Einheiten-Erzeugung (Christian Stiens)}
\label{subsec:einheiten-erzeugung}
% - Einheiten-Tabelle (alle 12 Einheiten mit Stats)
% - Pattern-Bezug: Factory Method
Jede der vier Fraktionen hat 3 verschiedene Einheitentypen. die in

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/FireFaction}
	\caption{Einheiten der Feuer-Fraktion}
	\label{fig:fireFaction}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/WaterFaction}
	\caption{Einheiten der Wasser-Fraktion}
	\label{fig:waterFaction}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/EarthFaction}
	\caption{Einheiten der Erd-Fraktion}
	\label{fig:earthFaction}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/AirFaction}
	\caption{Einheiten der Luft-Fraktion}
	\label{fig:airFaction}
\end{figure}

\subsubsection{Spielfeld \& Gelände (Max Meier)}
\label{subsec:spielfeld-gelaende}
% - Pattern-Bezug: Builder, Composite, Visitor
Die Erzeugung des Spielfelds (Anforderung F1, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) erfolgt über den \texttt{GameBuilder} (Builder Pattern).
Über eine Fluent-API werden zunächst Fraktionen registriert, optional eine benutzerdefinierte Geländeverteilung gesetzt und Einheiten hinzugefügt.
Die \texttt{build()}-Methode validiert die Konfiguration, erzeugt das \texttt{Battlefield} und platziert die Einheiten in den Ecken-Spawn-Zonen.

\begin{lstlisting}[language=Java, caption={GameBuilder -- Fluent-API und Build-Methode}, label={lst:builder-build}]
public GameBuilder withFactions(Faction... factions) {
    validateFactionCount(factions.length);
    this.factions.addAll(Arrays.asList(factions));
    return this;
}

public Game build() {
    validate();
    Battlefield battlefield = createAndInitializeBattlefield();
    Game game = new Game(battlefield);
    placeUnitsOnBattlefield(game);
    setInitialFaction(game);
    return game;
}

private void validate() {
    validateFactionsPresent();
    validateEachFactionHasUnits();
}
\end{lstlisting}

Listing~\ref{lst:builder-build} zeigt die Fluent-API und die \texttt{build()}-Methode.
\texttt{withFactions()} validiert die Fraktionsanzahl und gibt \texttt{this} zurück.
\texttt{build()} prüft, ob jede Fraktion Einheiten besitzt, initialisiert das \texttt{Battlefield} mit der Geländeverteilung und platziert die Einheiten in 3$\times$3-Spawn-Regionen an den Ecken (vgl. \texttt{GameBuilder.java Z.\,164ff}).

Das Spielfeld ist als Composite-Hierarchie aufgebaut: Das Interface \texttt{BattlefieldComponent} wird von \texttt{Cell} (Leaf), \texttt{Region} (Composite) und \texttt{Battlefield} (Root-Composite) implementiert.

\begin{lstlisting}[language=Java, caption={Composite-Hierarchie -- Cell, Region und Battlefield}, label={lst:composite-hierarchy}]
// BattlefieldComponent.java -- Component-Interface
public interface BattlefieldComponent {
    List<Cell> cells();
    default void applyEffect(Consumer<Cell> effect) {
        cells().forEach(effect);
    }
}

// Cell.java -- Leaf
public class Cell implements BattlefieldComponent {
    @Override
    public List<Cell> cells() { return List.of(this); }
}

// Region.java -- Composite
public record Region(List<Cell> cells)
        implements BattlefieldComponent {
    @Override
    public List<Cell> cells() { return new ArrayList<>(cells); }
}

// Battlefield.java -- Root-Composite
public class Battlefield implements BattlefieldComponent {
    private final List<Region> rows;
    @Override
    public List<Cell> cells() {
        return rows.stream()
            .flatMap(row -> row.cells().stream()).toList();
    }
}
\end{lstlisting}

Listing~\ref{lst:composite-hierarchy} zeigt die drei Ebenen der Composite-Hierarchie.
\texttt{Cell} gibt als Leaf eine Einelementliste zurück, \texttt{Region} delegiert an ihre Zellen, \texttt{Battlefield} flacht alle Zeilen ab.
\texttt{applyEffect(Consumer<Cell>)} wendet denselben Effekt -- etwa Wald zu Lava bei einem Waldbrand-Event -- auf eine einzelne Zelle, eine 3$\times$3-Region oder das gesamte Spielfeld an (vgl. \texttt{BattlefieldComponent.java Z.\,53ff}).

Die Geländeeffekte auf Einheiten werden über das Visitor Pattern abgebildet.
Jeder Geländetyp besitzt einen eigenen \texttt{TerrainVisitor}, der fraktionsspezifische Boni oder Mali berechnet.

\begin{lstlisting}[language=Java, caption={Visitor -- TerrainVisitor und LavaTerrainVisitor}, label={lst:visitor-lava}]
// TerrainVisitor.java
public interface TerrainVisitor {
    TerrainEffectResult visitFireUnit(Unit unit);
    TerrainEffectResult visitWaterUnit(Unit unit);
    TerrainEffectResult visitEarthUnit(Unit unit);
    TerrainEffectResult visitAirUnit(Unit unit);
}

// LavaTerrainVisitor.java
public class LavaTerrainVisitor
        extends AbstractTerrainVisitor {
    private static final int FIRE_ATTACK_BONUS = 2;
    private static final int WATER_HP_DRAIN = -5;

    @Override
    public TerrainEffectResult visitFireUnit(Unit unit) {
        return createAttackBonus(FIRE_ATTACK_BONUS,
            unit.getName() + ": +2 Angriff auf Lava");
    }

    @Override
    public TerrainEffectResult visitWaterUnit(Unit unit) {
        return createPerTurnEffect(WATER_HP_DRAIN,
            unit.getName() + ": -5 LP/Runde auf Lava");
    }
    // visitEarthUnit(), visitAirUnit() -> NEUTRAL (geerbt)
}
\end{lstlisting}

Listing~\ref{lst:visitor-lava} zeigt das \texttt{TerrainVisitor}-Interface und den \texttt{LavaTerrainVisitor}.
Feuer-Einheiten erhalten +2~Angriff, Wasser-Einheiten $-5$~LP/Runde; Erde und Luft erben \texttt{NEUTRAL} aus \texttt{AbstractTerrainVisitor}.
\texttt{Unit.accept(TerrainVisitor)} realisiert den Double Dispatch per \texttt{switch} über die Fraktion (vgl. \texttt{Unit.java Z.\,168ff}).
Die \texttt{TerrainVisitorFactory} hält die fünf zustandslosen Visitor-Instanzen in einer \texttt{EnumMap} und liefert sie in $O(1)$ aus (vgl. \texttt{TerrainVisitorFactory.java Z.\,36ff}).

\subsection{Spiellogik}
\label{sec:spiellogik}

\subsubsection{Rundenablauf \& Phasen (Christian Stiens)}
\label{subsec:rundenablauf}
% - Aktionen pro Runde: 1× Bewegen, 1× Angreifen
% - Zugwechsel zwischen Fraktionen
% - Pattern-Bezug: State / Decorator

Das Spiel ist in vier Phasen gegliedert, die über das State Pattern abgebildet werden.
Die erste Phase ist die \texttt{SetupPhase}, in welcher grundlegende Initialisierungen vorgenommen werden, etwa die Festlegung des startenden Spielers sowie die Instanziierung des \texttt{RoundManager} (vgl. Game.java Z. 59ff, 78ff).
Die \texttt{SetupPhase} geht über in die \texttt{PlayerTurnPhase}, in der zunächst mit rundenweise steigender Wahrscheinlichkeit ein zufällig gewählter (De-)Buff aus einem Pool von sechs Effekten auf eine zufällige Einheit des aktiven Spielers angewendet wird (vgl. \texttt{PlayerTurnPhase.java Z. 26ff} bzw. \texttt{BuffDebuffManager.java}).
Anschließend werden die Einheiten der aktiven Fraktion für den Spielzug vorbereitet, indem jede Einheit ihre maximale Aktionsanzahl (2) sowie die entsprechende Bewegungsreichweite zurückerhält.
Die \texttt{PlayerTurnPhase} wird durch Spielereingabe beendet und geht entweder in die \texttt{GameOverPhase} (falls der gegnerische Spieler besiegt wurde) oder die \texttt{EventPhase} über.
In der \texttt{EventPhase} wird eines von drei Events gefeuert, welches Einfluss auf die Geländebeschaffenheit haben kann.
Anschließend beginnt eine neue \texttt{PlayerTurnPhase}



\subsubsection{Bewegung \& Angriffsstrategie (Max Meier)}
\label{subsec:bewegung-angriffsstrategie}
% - Pattern-Bezug: Strategy
Die Bewegungs- und Angriffslogik (Anforderung F4, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) wird über das Strategy Pattern in zwei Hierarchien gekapselt.
Das Interface \texttt{MovementStrategy} definiert die Berechnung von Geländekosten und die Zugvalidierung.
\texttt{GroundMovementStrategy} berücksichtigt fraktionsspezifische Modifikatoren (z.\,B. Feuer auf Lava: Kosten~1 statt~2, Wasser auf Lava: Kosten~3), während \texttt{FlyingMovementStrategy} alle Geländekosten pauschal auf~1 setzt.

\begin{lstlisting}[language=Java, caption={Strategy Pattern -- MovementStrategy und FlyingMovementStrategy}, label={lst:strategy-movement}]
// MovementStrategy.java
public interface MovementStrategy {
    double calculateMovementCost(Terrain terrain);
    boolean canMoveTo(Game game, Position current,
                      Position target, int maxMovement);
}

// FlyingMovementStrategy.java
public class FlyingMovementStrategy
        implements MovementStrategy {
    private static final double FLYING_TERRAIN_COST = 1.0;

    @Override
    public double calculateMovementCost(Terrain terrain) {
        return FLYING_TERRAIN_COST;
    }

    @Override
    public boolean canMoveTo(Game game, Position current,
                             Position target, int maxMov) {
        if (game.isPositionOccupied(target)) return false;
        return current.manhattanDistanceTo(target) <= maxMov;
    }
}
\end{lstlisting}

Listing~\ref{lst:strategy-movement} zeigt das \texttt{MovementStrategy}-Interface und die \texttt{FlyingMovementStrategy}.
Fliegende Einheiten (alle Luft-Einheiten sowie der Phönix der Feuer-Fraktion) erhalten diese Strategie und ignorieren damit sämtliche Geländekosten -- ihre effektive Reichweite entspricht stets dem Basis-Bewegungswert.

Listing~\ref{lst:strategy-ground} zeigt die \texttt{GroundMovementStrategy} mit fraktionsspezifischen Geländemodifikatoren (vgl. \texttt{GroundMovementStrategy.java Z.\,44ff}).

\begin{lstlisting}[language=Java, caption={GroundMovementStrategy -- fraktionsspezifische Geländekosten}, label={lst:strategy-ground}]
public class GroundMovementStrategy
        implements MovementStrategy {

    private static final double FIRE_LAVA_COST = 1.0;
    private static final double FIRE_ICE_COST = 2.0;
    private static final double WATER_ICE_COST = 1.0;
    private static final double WATER_LAVA_COST = 3.0;

    private final Faction faction;

    @Override
    public double calculateMovementCost(Terrain terrain) {
        double baseCost = terrain.getMovementCost();
        return switch (faction) {
            case FIRE  -> applyFireModifiers(terrain, baseCost);
            case WATER -> applyWaterModifiers(terrain, baseCost);
            case EARTH -> applyEarthModifiers(terrain, baseCost);
            default    -> baseCost;
        };
    }

    private double applyFireModifiers(Terrain t, double base) {
        return switch (t) {
            case LAVA -> FIRE_LAVA_COST;   // Kosten 1 statt 2
            case ICE  -> FIRE_ICE_COST;    // Kosten 2 statt 3
            default   -> base;
        };
    }

    private double applyWaterModifiers(Terrain t, double base) {
        return switch (t) {
            case ICE  -> WATER_ICE_COST;   // Kosten 1 statt 3
            case LAVA -> WATER_LAVA_COST;  // Kosten 3 statt 2
            default   -> base;
        };
    }

    private double applyEarthModifiers(Terrain t, double base) {
        return switch (t) {
            case STONE -> 2.0;             // Kosten 2 statt 3
            default    -> base;
        };
    }
}
\end{lstlisting}

Die Kosten variieren je nach Fraktion und Gelände: Feuer auf Lava~1 statt~2, Wasser auf Eis~1 statt~3, dafür auf Lava~3 statt~2, Erde auf Stein~2 statt~3.
Fliegende Einheiten zahlen pauschal~1.

\texttt{AttackStrategy} definiert die Methoden \texttt{canAttack()}, \texttt{calculateBaseDamage()} und \texttt{getAttackRange()}.
\texttt{MeleeAttackStrategy} prüft die Manhattan-Distanz gegen die Reichweite der Einheit (typischerweise~1).
\texttt{RangedAttackStrategy} validiert zusätzlich die Sichtlinie: Wald-Gelände auf dem Pfad zwischen Angreifer und Ziel blockiert den Angriff, sofern die Einheit nicht über die Eigenschaft \texttt{ignoresForestDefense} verfügt -- wie etwa der Flammen-Bogenschütze (vgl. \texttt{RangedAttackStrategy.java Z.\,52ff}).
Alle 12 konkreten Einheiten setzen ihre Strategien explizit im Konstruktor: 4~Einheiten erhalten \texttt{FlyingMovementStrategy} (Phoenix, WindDancer, StormCaller, SkyGuardian), 5~Einheiten \texttt{RangedAttackStrategy} -- davon der Flammen-Bogenschütze mit \texttt{ignoresForestDefense=true}, die übrigen mit \texttt{false}.
Die Getter in \texttt{Unit} (Z.\,142ff) enthalten \texttt{GroundMovementStrategy} bzw. \texttt{MeleeAttackStrategy} als Fallback-Default.

\subsubsection{Schadensberechnung (Christian Stiens)}
\label{subsec:schadensberechnung}
% - Schadensformel
% - Gelände-Modifikatoren
% - Elementare Stärken/Schwächen (+25%/-25%)
% - Pattern-Bezug: Chain of Responsibility

Die Schadensberechnung wird über das Chain of Responsibility Pattern abgebildet.
Jeder Angriff durchläuft dabei eine fest definierte Kette von fünf Handlern, die gemeinsam auf dem \texttt{DamageContext}-Objekt arbeiten und dieses schrittweise anreichern.

Die abstrakte Basisklasse \texttt{DamageHandler} hält eine Referenz auf den jeweils nächsten Handler und leitet den Kontext nach getaner Arbeit via \texttt{super.handle()} weiter (vgl. \texttt{DamageHandler.java Z. 22, 40ff}).
Die Kette wird im Konstruktor von \texttt{DamageCalculator} über fluente \texttt{setNext()}-Aufrufe zusammengestellt und durch \texttt{handlerChain.handle(context)} gestartet (vgl. \texttt{DamageCalculator.java Z. 25ff, 44}).
Der erste Handler, \texttt{BaseDamageHandler}, liest den Grundschaden über das Strategy Pattern aus und schreibt ihn in den Kontext (vgl. \texttt{BaseDamageHandler.java Z. 14ff}).
Der \texttt{FactionAdvantageHandler} wendet anschließend einen Multiplikator aus einer statischen Fraktionsmatrix an, etwa $\times 1{,}25$ bei Vorteil oder $\times 0{,}75$ bei Nachteil (vgl. \texttt{FactionAdvantageHandler.java Z. 25ff}).

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/Fraktions_Korrelationsmatrix}
	\caption{Fraktions-Korrelationsmatrix zur Berechnung von Angriffsvorteilen}
	\label{fig:fraktions-korrelationsmatrix}
\end{figure}

Der \texttt{TerrainEffectHandler} integriert das Visitor Pattern: Für Angreifer und Verteidiger wird je ein \texttt{TerrainVisitor} dispatcht, dessen Boni in den Kontext einfließen (vgl. \texttt{TerrainEffectHandler.java Z. 21ff}).
Der \texttt{SynergyBonusHandler} greift auf die aktiven Dekoratoren der angreifenden Einheit zu und summiert deren Angriffsboni, womit das Decorator Pattern in die Kette eingebunden wird (vgl. \texttt{SynergyBonusHandler.java Z. 16ff}).
Als terminaler Handler berechnet der \texttt{DefenseCalculationHandler} schließlich den Endschaden nach der Formel $\text{finalDamage} = \max(1,\ \text{totalAttack} - \text{totalDefense})$ und schreibt das Ergebnis in den Kontext (vgl. \texttt{DefenseCalculationHandler.java Z. 15ff}).
Der fertige Kontext wird anschließend in ein unveränderliches \texttt{DamageResult}-Record umgewandelt und vom \texttt{AttackCommand} genutzt, um den Schaden auf die Zieleinheit anzuwenden und die Observer zu benachrichtigen (vgl. \texttt{DamageContext.java Z. 90ff}, \texttt{AttackCommand.java Z. 91ff}).

\subsubsection{Buffs/Debuffs (Christian Stiens)}
\label{subsec:buffs-debuffs}
% - Temporäre (De-)Buffs zur Laufzeit
% - Pattern-Bezug: Decorator

Im Verlauf des Spiels wird mit rundenweise steigender Wahrscheinlichkeit (max. 60\%) zu Beginn eines jeden Spielzugs einer von 6 Effekten (3 Buffs, 3 Debuffs) auf eine zufällig ausgewählte, nicht tote Einheit der aktiven Fraktion angewendet (vgl. \texttt{BuffDebuffManager.java Z. 41ff}).
Dieser Effekt wird als Decorator an die Unit Klasse angefügt.

\subsubsection{Undo/Redo (Max Meier)}
\label{subsec:undo-redo}
% - Pattern-Bezug: Command
Das Undo/Redo-System (Anforderung F4, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) basiert auf dem Command Pattern.
Jede Spieleraktion wird als \texttt{Command}-Objekt mit eigener Validierungs-, Ausführungs- und Rücknahmelogik gekapselt.
Der \texttt{CommandExecutor} validiert ein Command, führt es aus und übergibt es an die \texttt{CommandHistory}.

\begin{lstlisting}[language=Java, caption={CommandHistory -- Undo/Redo mit zwei Stacks}, label={lst:command-history}]
public class CommandHistory {
    private final Deque<Command> executedCommands;
    private final Deque<Command> undoneCommands;

    public void push(Command command) {
        executedCommands.push(command);
        undoneCommands.clear(); // Neuer Befehl verwirft Redo
    }

    public Command popForUndo() {
        if (executedCommands.isEmpty()) return null;
        Command cmd = executedCommands.pop();
        undoneCommands.push(cmd);
        return cmd;
    }

    public Command popForRedo() {
        if (undoneCommands.isEmpty()) return null;
        Command cmd = undoneCommands.pop();
        executedCommands.push(cmd);
        return cmd;
    }

    public void clear() {
        executedCommands.clear();
        undoneCommands.clear();
    }
}
\end{lstlisting}

Listing~\ref{lst:command-history} zeigt die \texttt{CommandHistory} mit ihren zwei Stacks.
Der \texttt{executedCommands}-Stack enthält alle ausgeführten Befehle der aktuellen Runde; bei einem Undo wird der oberste Befehl auf den \texttt{undoneCommands}-Stack verschoben und seine \texttt{undo()}-Methode aufgerufen.
Ein Redo entnimmt umgekehrt vom \texttt{undoneCommands}-Stack und führt den Befehl erneut aus.
Sobald ein neuer Befehl per \texttt{push()} hinzugefügt wird, wird der Redo-Stack geleert, da der neue Befehl eine Verzweigung der bisherigen Aktionsfolge darstellt.
Bei Rundenwechsel leert \texttt{clear()} beide Stacks, sodass der Spieler nur Aktionen der laufenden Runde rückgängig machen kann (Per-Turn-Rollback).

\texttt{MoveCommand} speichert im Feld \texttt{previousPosition} die Ausgangsposition der Einheit und setzt diese bei \texttt{undo()} zurück (vgl. \texttt{MoveCommand.java Z.\,77ff}).
\texttt{AttackCommand} speichert die Lebenspunkte des Ziels vor dem Angriff (\texttt{targetPreviousHealth}) und heilt das Ziel bei \texttt{undo()} um die Differenz (vgl. \texttt{AttackCommand.java Z.\,86ff}).
Beide Commands dekrementieren bei Undo den Aktionszähler der Einheit, sodass die Aktion erneut zur Verfügung steht.

\begin{lstlisting}[language=Java, caption={AttackCommand -- execute() und undo()}, label={lst:attack-command}]
public class AttackCommand implements Command {

    private final Unit actor;
    private final Unit target;

    private int targetPreviousHealth;
    private int damageDealt;
    private boolean wasExecuted;

    @Override
    public void execute(Game game) {
        this.targetPreviousHealth = target.getCurrentHealth();

        DamageCalculator calculator = new DamageCalculator();
        DamageResult result =
            calculator.calculateDamage(actor, target, game);

        this.damageDealt = result.totalDamage();
        target.takeDamage(result.totalDamage());
        actor.incrementActionsThisTurn();
        actor.startAttacking();

        game.notifyObservers(
            new UnitAttackedEvent(actor, target, result));

        if (!target.isAlive()) {
            game.handleUnitDeath(target);
        }
        this.wasExecuted = true;
    }

    @Override
    public void undo(Game game) {
        if (!wasExecuted) {
            throw new IllegalStateException(
                "Cannot undo command that wasn't executed");
        }
        int healthToRestore =
            targetPreviousHealth - target.getCurrentHealth();
        if (healthToRestore > 0) {
            target.heal(healthToRestore);
        }
        actor.decrementActionsThisTurn();
    }
}
\end{lstlisting}

Listing~\ref{lst:attack-command} zeigt den \texttt{AttackCommand}.
\texttt{execute()} sichert \texttt{targetPreviousHealth}, berechnet den Schaden über den \texttt{DamageCalculator} (Chain of Responsibility) und benachrichtigt die Observer per \texttt{UnitAttackedEvent}.
\texttt{undo()} heilt das Ziel um die Differenz und dekrementiert den Aktionszähler.

\subsection{Benutzeroberfläche (Christian Stiens)}
\label{sec:ui}

% - ASCII-Darstellung des Spielfelds
% - Eingabe-Aktionen: [B]ewegen, [A]ngreifen, [U]ndo, [R]edo, [Z]ug beenden
% - Ggf. Screenshot
% - Pattern-Bezug: Observer
Das 10x10 Spielfeld wird als ASCII in der Konsole gerendert.
Eine echte grafische Oberfläche hätte nach Ansicht der Autoren den zeitlichen Rahmen des Projektes gesprengt.
Über Konsoleneingaben ([B]ewegen, [A]ngreifen, [U]ndo, [R]edo, [Z]ug beenden) gibt der Spieler seinen Zug an.



