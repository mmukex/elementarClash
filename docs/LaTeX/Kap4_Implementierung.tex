\chapter{Implementierung}
\label{chap:implementierung}

% === ZIELUMFANG: ca. 4 Seiten ===

\section{Spielobjekte}
\label{sec:spielobjekte}

\subsection{Einheiten-Erzeugung (Christian Stiens)}
\label{subsec:einheiten-erzeugung}
% - Einheiten-Tabelle (alle 12 Einheiten mit Stats)
% - Pattern-Bezug: Factory Method
Jede der vier Fraktionen hat 3 verschiedene Einheitentypen.

\subsection{Spielfeld \& Gelände (Max Meier)}
\label{subsec:spielfeld-gelaende}
% - Gelände-Tabelle (Bewegungskosten, Boni, Fraktions-Effekte)
% - Pattern-Bezug: Builder, Composite, Visitor

\section{Spiellogik}
\label{sec:spiellogik}

\subsection{Rundenablauf \& Phasen (Christian Stiens)}
\label{subsec:rundenablauf}
% - Aktionen pro Runde: 1× Bewegen, 1× Angreifen
% - Zugwechsel zwischen Fraktionen
% - Pattern-Bezug: State / Decorator

Das Spiel ist in vier Phasen gegliedert, die über das State Pattern abgebildet werden.
Die erste Phase ist die \texttt{SetupPhase}, in welcher grundlegende Initialisierungen vorgenommen werden, etwa die Festlegung des startenden Spielers sowie die Instanziierung des \texttt{RoundManager} (vgl. Game.java Z. 59ff, 78ff).
Die \texttt{SetupPhase} geht über in die \texttt{PlayerTurnPhase}, in der zunächst mit rundenweise steigender Wahrscheinlichkeit ein zufällig gewählter (De-)Buff aus einem Pool von sechs Effekten auf eine zufällige Einheit des aktiven Spielers angewendet wird (vgl. \texttt{PlayerTurnPhase.java Z. 26ff} bzw. \texttt{BuffDebuffManager.java}).
Anschließend werden die Einheiten der aktiven Fraktion für den Spielzug vorbereitet, indem jede Einheit ihre maximale Aktionsanzahl (2) sowie die entsprechende Bewegungsreichweite zurückerhält.
Die \texttt{PlayerTurnPhase} wird durch Spielereingabe beendet und geht entweder in die \texttt{GameOverPhase} (falls der gegnerische Spieler besiegt wurde) oder die \texttt{EventPhase} über.
In der \texttt{EventPhase} wird eines von drei Events gefeuert, welches Einfluss auf die Geländebeschaffenheit haben kann.
Anschließend beginnt eine neue \texttt{PlayerTurnPhase}



\subsection{Bewegung \& Angriffsstrategie (Max Meier)}
\label{subsec:bewegung-angriffsstrategie}
% - Boden-/Flugbewegung, Nahkampf/Fernkampf
% - Pattern-Bezug: Strategy

\subsection{Schadensberechnung (Christian Stiens)}
\label{subsec:schadensberechnung}
% - Schadensformel
% - Gelände-Modifikatoren
% - Elementare Stärken/Schwächen (+25%/-25%)
% - Pattern-Bezug: Chain of Responsibility

Die Schadensberechnung wird über das Chain of Responsibility Pattern abgebildet.
Jeder Angriff durchläuft dabei eine fest definierte Kette von fünf Handlern, die gemeinsam auf dem \texttt{DamageContext}-Objekt arbeiten und dieses schrittweise anreichern.

Die abstrakte Basisklasse \texttt{DamageHandler} hält eine Referenz auf den jeweils nächsten Handler und leitet den Kontext nach getaner Arbeit via \texttt{super.handle()} weiter (vgl. \texttt{DamageHandler.java Z. 22, 40ff}).
Die Kette wird im Konstruktor von \texttt{DamageCalculator} über fluente \texttt{setNext()}-Aufrufe zusammengestellt und durch \texttt{handlerChain.handle(context)} gestartet (vgl. \texttt{DamageCalculator.java Z. 25ff, 44}).
Der erste Handler, \texttt{BaseDamageHandler}, liest den Grundschaden über das Strategy Pattern aus und schreibt ihn in den Kontext (vgl. \texttt{BaseDamageHandler.java Z. 14ff}).
Der \texttt{FactionAdvantageHandler} wendet anschließend einen Multiplikator aus einer statischen Fraktionsmatrix an, etwa $\times 1{,}25$ bei Vorteil oder $\times 0{,}75$ bei Nachteil (vgl. \texttt{FactionAdvantageHandler.java Z. 25ff}).

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/Fraktions_Korrelationsmatrix}
	\caption{Fraktions-Korrelationsmatrix zur Berechnung von Angriffsvorteilen}
	\label{fig:fraktions-korrelationsmatrix}
\end{figure}

Der \texttt{TerrainEffectHandler} integriert das Visitor Pattern: Für Angreifer und Verteidiger wird je ein \texttt{TerrainVisitor} dispatcht, dessen Boni in den Kontext einfließen (vgl. \texttt{TerrainEffectHandler.java Z. 21ff}).
Der \texttt{SynergyBonusHandler} greift auf die aktiven Dekoratoren der angreifenden Einheit zu und summiert deren Angriffsboni, womit das Decorator Pattern in die Kette eingebunden wird (vgl. \texttt{SynergyBonusHandler.java Z. 16ff}).
Als terminaler Handler berechnet der \texttt{DefenseCalculationHandler} schließlich den Endschaden nach der Formel $\text{finalDamage} = \max(1,\ \text{totalAttack} - \text{totalDefense})$ und schreibt das Ergebnis in den Kontext (vgl. \texttt{DefenseCalculationHandler.java Z. 15ff}).
Der fertige Kontext wird anschließend in ein unveränderliches \texttt{DamageResult}-Record umgewandelt und vom \texttt{AttackCommand} genutzt, um den Schaden auf die Zieleinheit anzuwenden und die Observer zu benachrichtigen (vgl. \texttt{DamageContext.java Z. 90ff}, \texttt{AttackCommand.java Z. 91ff}).

\subsection{Buffs/Debuffs (Christian Stiens)}
\label{subsec:buffs-debuffs}
% - Temporäre (De-)Buffs zur Laufzeit
% - Pattern-Bezug: Decorator

Im Verlauf des Spiels wird mit rundenweise steigender Wahrscheinlichkeit (max. 60\%) zu Beginn eines jeden Spielzugs einer von 6 Effekten (3 Buffs, 3 Debuffs) auf eine zufällig ausgewählte, nicht tote Einheit der aktiven Fraktion angewendet (vgl. \texttt{BuffDebuffManager.java Z. 41ff}).
Dieser Effekt wird als Decorator an die Unit Klasse angefügt.

\subsection{Undo/Redo (Max Meier)}
\label{subsec:undo-redo}
% - Per-Turn Rollback
% - CommandHistory mit zwei Stacks
% - Pattern-Bezug: Command

\section{Benutzeroberfläche (Christian Stiens)}
\label{sec:ui}

% - ASCII-Darstellung des Spielfelds
% - Eingabe-Aktionen: [B]ewegen, [A]ngreifen, [U]ndo, [R]edo, [Z]ug beenden
% - Ggf. Screenshot
% - Pattern-Bezug: Observer
Das 10x10 Spielfeld wird als ASCII in der Konsole gerendert.
Eine echte grafische Oberfläche hätte nach Ansicht der Autoren den zeitlichen Rahmen des Projektes gesprengt.
Über Konsoleneingaben ([B]ewegen, [A]ngreifen, [U]ndo, [R]edo, [Z]ug beenden) gibt der Spieler seinen Zug an.



