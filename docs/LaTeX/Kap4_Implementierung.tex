\section{Implementierung}
\label{chap:implementierung}

% === ZIELUMFANG: ca. 4 Seiten ===

\subsection{Spielobjekte}
\label{sec:spielobjekte}

\subsubsection{Einheiten-Erzeugung (Christian Stiens)}
\label{subsec:einheiten-erzeugung}
% - Einheiten-Tabelle (alle 12 Einheiten mit Stats)
% - Pattern-Bezug: Factory Method
Jede der vier Fraktionen verfügt über drei Einheitentypen (vgl. Kapitel~2.3.1, Tabelle~\ref{tab:einheiten}).
Die Erzeugung erfolgt ausschließlich über die jeweilige \texttt{UnitFactory}-Subklasse (Factory Method Pattern), da alle konkreten Einheitenklassen package-private sind.

\begin{lstlisting}[language=Java, caption={UnitFactory -- Template Method und FireUnitFactory -- Factory Method}, label={lst:factory-method}]
// UnitFactory.java -- Abstract Creator
public abstract class UnitFactory {
    private final Faction faction;
    private int unitCounter = 0;

    public final Unit createUnit(UnitType type) {
        if (!isValidTypeForFaction(type)) {
            throw new IllegalArgumentException(
                "Unit type " + type + " not valid for " + faction);
        }
        String id = faction.name().substring(0, 1) + (++unitCounter);
        return createUnitInternal(id, type);   // Factory Method
    }

    protected abstract Unit createUnitInternal(String id, UnitType type);
    protected abstract boolean isValidTypeForFaction(UnitType type);
}

// FireUnitFactory.java -- Concrete Creator
public class FireUnitFactory extends UnitFactory {
    public FireUnitFactory() { super(Faction.FIRE); }

    @Override
    protected Unit createUnitInternal(String id, UnitType type) {
        return switch (type) {
            case INFERNO_WARRIOR -> new InfernoWarrior(id,
                    new UnitStats(100, 15, 5, 3, 1));
            case FLAME_ARCHER    -> new FlameArcher(id,
                    new UnitStats(70, 12, 3, 4, 3));
            case PHOENIX         -> new Phoenix(id,
                    new UnitStats(80, 10, 4, 5, 1));
            default -> throw new IllegalArgumentException(type.toString());
        };
    }
}
\end{lstlisting}

Listing~\ref{lst:factory-method} zeigt das zweistufige Muster.
\texttt{createUnit()} in \texttt{UnitFactory} ist die finale Template-Method: Sie validiert den \texttt{UnitType} per \texttt{isValidTypeForFaction()}, generiert eine eindeutige ID (z.\,B. \texttt{"F1"} für die erste Feuer-Einheit, \texttt{"W2"} für die zweite Wasser-Einheit) und delegiert die eigentliche Instanziierung an die abstrakte Factory Method \texttt{createUnitInternal()}.
\texttt{FireUnitFactory} implementiert diese per \texttt{switch}-Ausdruck und übergibt die fraktionsspezifischen Stat-Werte als \texttt{UnitStats}-Record direkt an den Konstruktor der konkreten, package-privaten Einheitenklasse.
Der \texttt{GameBuilder} hält ausschließlich Referenzen auf die abstrakte \texttt{UnitFactory} und \texttt{Unit}; konkrete Klassen sind für ihn nicht sichtbar.

\subsubsection{Spielfeld \& Gelände (Max Meier)}
\label{subsec:spielfeld-gelaende}
% - Pattern-Bezug: Builder, Composite, Visitor
Die Erzeugung des Spielfelds (Anforderung F1, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) erfolgt über den \texttt{GameBuilder} (Builder Pattern).
Über eine Fluent-API werden zunächst Fraktionen registriert, optional eine benutzerdefinierte Geländeverteilung gesetzt und Einheiten hinzugefügt.
Die \texttt{build()}-Methode validiert die Konfiguration, erzeugt das \texttt{Battlefield} und platziert die Einheiten in den Ecken-Spawn-Zonen.

\begin{lstlisting}[language=Java, caption={GameBuilder -- Fluent-API und Build-Methode}, label={lst:builder-build}]
public GameBuilder withFactions(Faction... factions) {
    validateFactionCount(factions.length);
    this.factions.addAll(Arrays.asList(factions));
    return this;
}

public Game build() {
    validate();
    Battlefield battlefield = createAndInitializeBattlefield();
    Game game = new Game(battlefield);
    placeUnitsOnBattlefield(game);
    setInitialFaction(game);
    return game;
}

private void validate() {
    validateFactionsPresent();
    validateEachFactionHasUnits();
}
\end{lstlisting}

Listing~\ref{lst:builder-build} zeigt die Fluent-API und die \texttt{build()}-Methode.
\texttt{withFactions()} validiert die Fraktionsanzahl und gibt \texttt{this} zurück.
\texttt{build()} prüft, ob jede Fraktion Einheiten besitzt, initialisiert das \texttt{Battlefield} mit der Geländeverteilung und platziert die Einheiten in 3$\times$3-Spawn-Regionen an den Ecken (vgl. \texttt{GameBuilder.java Z.\,164ff}).

Das Spielfeld ist als Composite-Hierarchie aufgebaut: Das Interface \texttt{BattlefieldComponent} wird von \texttt{Cell} (Leaf), \texttt{Region} (Composite) und \texttt{Battlefield} (Root-Composite) implementiert.

\begin{lstlisting}[language=Java, caption={Composite-Hierarchie -- Cell, Region und Battlefield}, label={lst:composite-hierarchy}]
// BattlefieldComponent.java -- Component-Interface
public interface BattlefieldComponent {
    List<Cell> cells();
    default void applyEffect(Consumer<Cell> effect) {
        cells().forEach(effect);
    }
}

// Cell.java -- Leaf
public class Cell implements BattlefieldComponent {
    @Override
    public List<Cell> cells() { return List.of(this); }
}

// Region.java -- Composite
public record Region(List<Cell> cells)
        implements BattlefieldComponent {
    @Override
    public List<Cell> cells() { return new ArrayList<>(cells); }
}

// Battlefield.java -- Root-Composite
public class Battlefield implements BattlefieldComponent {
    private final List<Region> rows;
    @Override
    public List<Cell> cells() {
        return rows.stream()
            .flatMap(row -> row.cells().stream()).toList();
    }
}
\end{lstlisting}

Listing~\ref{lst:composite-hierarchy} zeigt die drei Ebenen der Composite-Hierarchie.
\texttt{Cell} gibt als Leaf eine Einelementliste zurück, \texttt{Region} delegiert an ihre Zellen, \texttt{Battlefield} flacht alle Zeilen ab.
\texttt{applyEffect(Consumer<Cell>)} wendet denselben Effekt -- etwa Wald zu Lava bei einem Waldbrand-Event -- auf eine einzelne Zelle, eine 3$\times$3-Region oder das gesamte Spielfeld an (vgl. \texttt{BattlefieldComponent.java Z.\,53ff}).

Die Geländeeffekte auf Einheiten werden über das Visitor Pattern abgebildet.
Jeder Geländetyp besitzt einen eigenen \texttt{TerrainVisitor}, der fraktionsspezifische Boni oder Mali berechnet.

\begin{lstlisting}[language=Java, caption={Visitor -- TerrainVisitor und LavaTerrainVisitor}, label={lst:visitor-lava}]
// TerrainVisitor.java
public interface TerrainVisitor {
    TerrainEffectResult visitFireUnit(Unit unit);
    TerrainEffectResult visitWaterUnit(Unit unit);
    TerrainEffectResult visitEarthUnit(Unit unit);
    TerrainEffectResult visitAirUnit(Unit unit);
}

// LavaTerrainVisitor.java
public class LavaTerrainVisitor
        extends AbstractTerrainVisitor {
    private static final int FIRE_ATTACK_BONUS = 2;
    private static final int WATER_HP_DRAIN = -5;

    @Override
    public TerrainEffectResult visitFireUnit(Unit unit) {
        return createAttackBonus(FIRE_ATTACK_BONUS,
            unit.getName() + ": +2 Angriff auf Lava");
    }

    @Override
    public TerrainEffectResult visitWaterUnit(Unit unit) {
        return createPerTurnEffect(WATER_HP_DRAIN,
            unit.getName() + ": -5 LP/Runde auf Lava");
    }
    // visitEarthUnit(), visitAirUnit() -> NEUTRAL (geerbt)
}
\end{lstlisting}

Listing~\ref{lst:visitor-lava} zeigt das \texttt{TerrainVisitor}-Interface und den \texttt{LavaTerrainVisitor}.
Feuer-Einheiten erhalten +2~Angriff, Wasser-Einheiten $-5$~LP/Runde; Erde und Luft erben \texttt{NEUTRAL} aus \texttt{AbstractTerrainVisitor}.
\texttt{Unit.accept(TerrainVisitor)} realisiert den Double Dispatch per \texttt{switch} über die Fraktion (vgl. \texttt{Unit.java Z.\,168ff}).
Die \texttt{TerrainVisitorFactory} hält die fünf zustandslosen Visitor-Instanzen in einer \texttt{EnumMap} und liefert sie in $O(1)$ aus (vgl. \texttt{TerrainVisitorFactory.java Z.\,36ff}).

\subsection{Spiellogik}
\label{sec:spiellogik}

\subsubsection{Rundenablauf \& Phasen (Christian Stiens)}
\label{subsec:rundenablauf}
% - Aktionen pro Runde: 1× Bewegen, 1× Angreifen
% - Zugwechsel zwischen Fraktionen
% - Pattern-Bezug: State / Decorator

Der Spielablauf ist als Zustandsautomat über das State Pattern realisiert (Anforderung F3, vgl. Tabelle~\ref{tab:funktionale-anforderungen}).
Alle Phasenwechsel laufen über \texttt{Game.transitionToPhase()}, die \texttt{onExit()} der alten und \texttt{onEnter()} der neuen Phase aufruft -- der Mechanismus ist damit an genau einer Stelle konzentriert.

\begin{lstlisting}[language=Java, caption={State Pattern -- transitionToPhase() und PlayerTurnPhase}, label={lst:state-transition}]
// Game.java -- Context
private void transitionToPhase(GamePhaseState newPhase) {
    currentPhase.onExit(this);
    this.currentPhase = newPhase;
    newPhase.onEnter(this);
}

// PlayerTurnPhase.java -- Concrete State (Record)
public record PlayerTurnPhase(Faction activeFaction)
        implements GamePhaseState {

    @Override
    public void onEnter(Game game) {
        // Decorator Pattern: (De-)Buff mit steigender Wahrscheinlichkeit
        new BuffDebuffManager()
            .tryApplyRandomEffect(game, game.getRoundNumber());
        // Aktionszaehler aller Einheiten der Fraktion zuruecksetzen
        game.getUnitsOfFaction(activeFaction).forEach(Unit::resetTurn);
    }

    @Override
    public boolean canExecuteCommand(Game game, Command command) {
        return command.validate(game).isValid();
    }

    @Override
    public GamePhaseState transitionToEventPhase(Game game) {
        return EventPhase.getInstance();
    }

    @Override
    public GamePhaseState transitionToGameOver(Game game, Faction winner) {
        return new GameOverPhase(winner);
    }
}
\end{lstlisting}

Listing~\ref{lst:state-transition} zeigt den Phasenwechsel-Mechanismus und die zentrale \texttt{PlayerTurnPhase}.
Da \texttt{PlayerTurnPhase} ein Java-Record ist, enthält sie die aktive Fraktion unveränderlich als Komponente -- ein Wechsel der Fraktion erzeugt eine neue Instanz (\texttt{transitionToPlayerTurn()} gibt \texttt{new PlayerTurnPhase(faction)} zurück).
In \texttt{onEnter()} werden zwei Aufgaben erledigt: der \texttt{BuffDebuffManager} versucht, einen Dekorator auf eine Einheit anzuwenden (Decorator Pattern), und anschließend werden alle Einheiten der aktiven Fraktion für den neuen Zug zurückgesetzt -- konkret setzt \texttt{Unit.resetTurn()} den Aktionszähler auf~0 und wechselt den \texttt{UnitState} per State Pattern nach \texttt{IdleState}.
\texttt{canExecuteCommand()} delegiert vollständig an \texttt{command.validate(game)}, sodass die Phasenklasse keine Kenntnis der einzelnen Command-Typen benötigt.
Die \texttt{EventPhase} blockiert alle Befehle, feuert in \texttt{onEnter()} ein zufälliges Geländeereignis (Waldbrand, Geysir oder Erdbeben über \texttt{applyEffect()} des Composite-Spielfelds) und geht danach automatisch in die nächste \texttt{PlayerTurnPhase} über.



\subsubsection{Bewegung \& Angriffsstrategie (Max Meier)}
\label{subsec:bewegung-angriffsstrategie}
% - Pattern-Bezug: Strategy
Die Bewegungs- und Angriffslogik (Anforderung F4, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) wird über das Strategy Pattern in zwei Hierarchien gekapselt.
Das Interface \texttt{MovementStrategy} definiert die Berechnung von Geländekosten und die Zugvalidierung.
\texttt{GroundMovementStrategy} berücksichtigt fraktionsspezifische Modifikatoren (z.\,B. Feuer auf Lava: Kosten~1 statt~2, Wasser auf Lava: Kosten~3), während \texttt{FlyingMovementStrategy} alle Geländekosten pauschal auf~1 setzt.

\begin{lstlisting}[language=Java, caption={Strategy Pattern -- MovementStrategy und FlyingMovementStrategy}, label={lst:strategy-movement}]
// MovementStrategy.java
public interface MovementStrategy {
    double calculateMovementCost(Terrain terrain);
    boolean canMoveTo(Game game, Position current,
                      Position target, int maxMovement);
}

// FlyingMovementStrategy.java
public class FlyingMovementStrategy
        implements MovementStrategy {
    private static final double FLYING_TERRAIN_COST = 1.0;

    @Override
    public double calculateMovementCost(Terrain terrain) {
        return FLYING_TERRAIN_COST;
    }

    @Override
    public boolean canMoveTo(Game game, Position current,
                             Position target, int maxMov) {
        if (game.isPositionOccupied(target)) return false;
        return current.manhattanDistanceTo(target) <= maxMov;
    }
}
\end{lstlisting}

Listing~\ref{lst:strategy-movement} zeigt das \texttt{MovementStrategy}-Interface und die \texttt{FlyingMovementStrategy}.
Fliegende Einheiten (alle Luft-Einheiten sowie der Phönix der Feuer-Fraktion) erhalten diese Strategie und ignorieren damit sämtliche Geländekosten -- ihre effektive Reichweite entspricht stets dem Basis-Bewegungswert.

Listing~\ref{lst:strategy-ground} zeigt die \texttt{GroundMovementStrategy} mit fraktionsspezifischen Geländemodifikatoren (vgl. \texttt{GroundMovementStrategy.java Z.\,44ff}).

\begin{lstlisting}[language=Java, caption={GroundMovementStrategy -- fraktionsspezifische Geländekosten}, label={lst:strategy-ground}]
public class GroundMovementStrategy
        implements MovementStrategy {

    private static final double FIRE_LAVA_COST = 1.0;
    private static final double FIRE_ICE_COST = 2.0;
    private static final double WATER_ICE_COST = 1.0;
    private static final double WATER_LAVA_COST = 3.0;

    private final Faction faction;

    @Override
    public double calculateMovementCost(Terrain terrain) {
        double baseCost = terrain.getMovementCost();
        return switch (faction) {
            case FIRE  -> applyFireModifiers(terrain, baseCost);
            case WATER -> applyWaterModifiers(terrain, baseCost);
            case EARTH -> applyEarthModifiers(terrain, baseCost);
            default    -> baseCost;
        };
    }

    private double applyFireModifiers(Terrain t, double base) {
        return switch (t) {
            case LAVA -> FIRE_LAVA_COST;   // Kosten 1 statt 2
            case ICE  -> FIRE_ICE_COST;    // Kosten 2 statt 3
            default   -> base;
        };
    }

    private double applyWaterModifiers(Terrain t, double base) {
        return switch (t) {
            case ICE  -> WATER_ICE_COST;   // Kosten 1 statt 3
            case LAVA -> WATER_LAVA_COST;  // Kosten 3 statt 2
            default   -> base;
        };
    }

    private double applyEarthModifiers(Terrain t, double base) {
        return switch (t) {
            case STONE -> 2.0;             // Kosten 2 statt 3
            default    -> base;
        };
    }
}
\end{lstlisting}

Die Kosten variieren je nach Fraktion und Gelände: Feuer auf Lava~1 statt~2, Wasser auf Eis~1 statt~3, dafür auf Lava~3 statt~2, Erde auf Stein~2 statt~3.
Fliegende Einheiten zahlen pauschal~1.

\texttt{AttackStrategy} definiert die Methoden \texttt{canAttack()}, \texttt{calculateBaseDamage()} und \texttt{getAttackRange()}.
\texttt{MeleeAttackStrategy} prüft die Manhattan-Distanz gegen die Reichweite der Einheit (typischerweise~1).
\texttt{RangedAttackStrategy} validiert zusätzlich die Sichtlinie: Wald-Gelände auf dem Pfad zwischen Angreifer und Ziel blockiert den Angriff, sofern die Einheit nicht über die Eigenschaft \texttt{ignoresForestDefense} verfügt -- wie etwa der Flammen-Bogenschütze (vgl. \texttt{RangedAttackStrategy.java Z.\,52ff}).
Alle 12 konkreten Einheiten setzen ihre Strategien explizit im Konstruktor: 4~Einheiten erhalten \texttt{FlyingMovementStrategy} (Phoenix, WindDancer, StormCaller, SkyGuardian), 5~Einheiten \texttt{RangedAttackStrategy} -- davon der Flammen-Bogenschütze mit \texttt{ignoresForestDefense=true}, die übrigen mit \texttt{false}.
Die Getter in \texttt{Unit} (Z.\,142ff) enthalten \texttt{GroundMovementStrategy} bzw. \texttt{MeleeAttackStrategy} als Fallback-Default.

\subsubsection{Schadensberechnung (Christian Stiens)}
\label{subsec:schadensberechnung}
% - Schadensformel
% - Gelände-Modifikatoren
% - Elementare Stärken/Schwächen (+25%/-25%)
% - Pattern-Bezug: Chain of Responsibility

Die Schadensberechnung wird über das Chain of Responsibility Pattern abgebildet.
Jeder Angriff durchläuft dabei eine fest definierte Kette von fünf Handlern, die gemeinsam auf dem \texttt{DamageContext}-Objekt arbeiten und dieses schrittweise anreichern.

\begin{lstlisting}[language=Java, caption={DamageCalculator -- Aufbau und Start der Handler-Kette}, label={lst:damage-calculator}]
// DamageCalculator.java
public class DamageCalculator {
    private final DamageHandler handlerChain;

    public DamageCalculator() {
        // Kette in fester Reihenfolge aufbauen (Reihenfolge entscheidend)
        this.handlerChain = new BaseDamageHandler();
        handlerChain
            .setNext(new FactionAdvantageHandler())
            .setNext(new TerrainEffectHandler())     // Visitor Pattern
            .setNext(new SynergyBonusHandler())      // Decorator Pattern
            .setNext(new DefenseCalculationHandler());
    }

    public DamageResult calculateDamage(Unit attacker,
                                        Unit target, Game game) {
        DamageContext context =
            new DamageContext(attacker, target, game);
        handlerChain.handle(context);   // Kette starten
        return context.toResult();      // unveraendl. Record
    }
}
\end{lstlisting}

Listing~\ref{lst:damage-calculator} zeigt, wie \texttt{DamageCalculator} die Kette einmalig im Konstruktor über fluente \texttt{setNext()}-Aufrufe aufbaut.
\texttt{calculateDamage()} erstellt einen frischen \texttt{DamageContext} für jeden Angriff, startet die Kette mit \texttt{handlerChain.handle(context)} und wandelt das fertige Kontextobjekt in ein unveränderliches \texttt{DamageResult}-Record um.

Die abstrakte Basisklasse \texttt{DamageHandler} hält eine Referenz auf den jeweils nächsten Handler und leitet den Kontext nach getaner Arbeit via \texttt{super.handle()} weiter (vgl. \texttt{DamageHandler.java Z.\,22, 40ff}).
Der erste Handler, \texttt{BaseDamageHandler}, liest den Grundschaden über das Strategy Pattern aus (\texttt{attacker.getAttackStrategy().calculateBaseDamage()}) und schreibt ihn in den Kontext (vgl. \texttt{BaseDamageHandler.java Z.\,14ff}).
Der \texttt{FactionAdvantageHandler} wendet anschließend einen Multiplikator aus einer statischen Fraktionsmatrix an, etwa $\times 1{,}25$ bei Vorteil oder $\times 0{,}75$ bei Nachteil (vgl. \texttt{FactionAdvantageHandler.java Z.\,25ff}, Tabelle~\ref{tab:fraktions-korrelationsmatrix}).

Der \texttt{TerrainEffectHandler} integriert das Visitor Pattern: Für Angreifer und Verteidiger wird je ein \texttt{TerrainVisitor} dispatcht, dessen Boni in den Kontext einfließen (vgl. \texttt{TerrainEffectHandler.java Z. 21ff}).
Der \texttt{SynergyBonusHandler} greift auf die aktiven Dekoratoren der angreifenden Einheit zu und summiert deren Angriffsboni, womit das Decorator Pattern in die Kette eingebunden wird (vgl. \texttt{SynergyBonusHandler.java Z. 16ff}).
Als terminaler Handler berechnet der \texttt{DefenseCalculationHandler} schließlich den Endschaden nach der Formel $\text{finalDamage} = \max(1,\ \text{totalAttack} - \text{totalDefense})$ und schreibt das Ergebnis in den Kontext (vgl. \texttt{DefenseCalculationHandler.java Z. 15ff}).
Der fertige Kontext wird anschließend in ein unveränderliches \texttt{DamageResult}-Record umgewandelt und vom \texttt{AttackCommand} genutzt, um den Schaden auf die Zieleinheit anzuwenden und die Observer zu benachrichtigen (vgl. \texttt{DamageContext.java Z. 90ff}, \texttt{AttackCommand.java Z. 91ff}).

\subsubsection{Buffs/Debuffs (Christian Stiens)}
\label{subsec:buffs-debuffs}
% - Temporäre (De-)Buffs zur Laufzeit
% - Pattern-Bezug: Decorator

Im Verlauf des Spiels wird mit rundenweise steigender Wahrscheinlichkeit (max. 60\,\%) zu Beginn jedes Spielerzugs einer von sechs Effekten auf eine zufällig ausgewählte, lebende Einheit der aktiven Fraktion angewendet (Decorator Pattern, vgl. \texttt{BuffDebuffManager.java Z.\,41ff}).

\begin{lstlisting}[language=Java, caption={Decorator Pattern -- Unit.getAttack() und AttackBuffDecorator}, label={lst:decorator-unit}]
// Unit.java -- Dekoratoren transparent integriert
public int getAttack() {
    int attack = baseStats.attack();
    for (UnitDecorator decorator : decorators) {
        if (!decorator.isExpired()) {
            attack += decorator.getAttackBonus(this);
        }
    }
    return attack;
}

public void removeExpiredDecorators() {
    decorators.removeIf(UnitDecorator::isExpired);
}

// AttackBuffDecorator.java -- Konkrete Decorator-Implementierung
public class AttackBuffDecorator extends UnitDecorator {
    private static final int BONUS = 2;
    private static final int DURATION = 2;
    private int remainingRounds = DURATION;

    @Override public int getAttackBonus(Unit unit) { return BONUS; }
    @Override public int getDefenseBonus(Unit unit) { return 0; }
    @Override public int getMovementBonus(Unit unit) { return 0; }
    @Override public boolean isExpired() { return remainingRounds <= 0; }
    @Override public void tick() { remainingRounds--; }
    @Override public String getDescription() {
        return "+2 Attack (" + remainingRounds + " rounds left)";
    }
}
\end{lstlisting}

Listing~\ref{lst:decorator-unit} zeigt die Integration des Decorator Patterns in \texttt{Unit}.
\texttt{getAttack()} iteriert über alle Dekoratoren, filtert abgelaufene per \texttt{isExpired()} und akkumuliert deren \texttt{getAttackBonus(this)} auf den Basiswert aus \texttt{baseStats}; \texttt{getDefense()} und \texttt{getMovement()} folgen demselben Muster.
\texttt{AttackBuffDecorator} gewährt +2~ATK für zwei Runden: \texttt{tick()} dekrementiert \texttt{remainingRounds} am Ende jedes Spielerzugs, \texttt{isExpired()} signalisiert bei \texttt{remainingRounds\,$\leq$\,0} das Ende der Wirkdauer.
\texttt{removeExpiredDecorators()} entfernt alle abgelaufenen Einträge in einem einzigen \texttt{removeIf()}-Aufruf (vgl. \texttt{Unit.java Z.\,210ff}).
Die aktiven Effekte sind im UI in geschweiften Klammern hinter dem Einheitennamen sichtbar, z.\,B. \texttt{\{+2 Attack (1 rounds left)\}}.

\subsubsection{Undo/Redo (Max Meier)}
\label{subsec:undo-redo}
% - Pattern-Bezug: Command
Das Undo/Redo-System (Anforderung F4, vgl. Tabelle~\ref{tab:funktionale-anforderungen}) basiert auf dem Command Pattern.
Jede Spieleraktion wird als \texttt{Command}-Objekt mit eigener Validierungs-, Ausführungs- und Rücknahmelogik gekapselt.
Der \texttt{CommandExecutor} validiert ein Command, führt es aus und übergibt es an die \texttt{CommandHistory}.

\begin{lstlisting}[language=Java, caption={CommandHistory -- Undo/Redo mit zwei Stacks}, label={lst:command-history}]
public class CommandHistory {
    private final Deque<Command> executedCommands;
    private final Deque<Command> undoneCommands;

    public void push(Command command) {
        executedCommands.push(command);
        undoneCommands.clear(); // Neuer Befehl verwirft Redo
    }

    public Command popForUndo() {
        if (executedCommands.isEmpty()) return null;
        Command cmd = executedCommands.pop();
        undoneCommands.push(cmd);
        return cmd;
    }

    public Command popForRedo() {
        if (undoneCommands.isEmpty()) return null;
        Command cmd = undoneCommands.pop();
        executedCommands.push(cmd);
        return cmd;
    }

    public void clear() {
        executedCommands.clear();
        undoneCommands.clear();
    }
}
\end{lstlisting}

Listing~\ref{lst:command-history} zeigt die \texttt{CommandHistory} mit ihren zwei Stacks.
Der \texttt{executedCommands}-Stack enthält alle ausgeführten Befehle der aktuellen Runde; bei einem Undo wird der oberste Befehl auf den \texttt{undoneCommands}-Stack verschoben und seine \texttt{undo()}-Methode aufgerufen.
Ein Redo entnimmt umgekehrt vom \texttt{undoneCommands}-Stack und führt den Befehl erneut aus.
Sobald ein neuer Befehl per \texttt{push()} hinzugefügt wird, wird der Redo-Stack geleert, da der neue Befehl eine Verzweigung der bisherigen Aktionsfolge darstellt.
Bei Rundenwechsel leert \texttt{clear()} beide Stacks, sodass der Spieler nur Aktionen der laufenden Runde rückgängig machen kann (Per-Turn-Rollback).

\texttt{MoveCommand} speichert im Feld \texttt{previousPosition} die Ausgangsposition der Einheit und setzt diese bei \texttt{undo()} zurück (vgl. \texttt{MoveCommand.java Z.\,77ff}).
\texttt{AttackCommand} speichert die Lebenspunkte des Ziels vor dem Angriff (\texttt{targetPreviousHealth}) und heilt das Ziel bei \texttt{undo()} um die Differenz (vgl. \texttt{AttackCommand.java Z.\,86ff}).
Beide Commands dekrementieren bei Undo den Aktionszähler der Einheit, sodass die Aktion erneut zur Verfügung steht.

\begin{lstlisting}[language=Java, caption={AttackCommand -- execute() und undo()}, label={lst:attack-command}]
public class AttackCommand implements Command {

    private final Unit actor;
    private final Unit target;

    private int targetPreviousHealth;
    private int damageDealt;
    private boolean wasExecuted;

    @Override
    public void execute(Game game) {
        this.targetPreviousHealth = target.getCurrentHealth();

        DamageCalculator calculator = new DamageCalculator();
        DamageResult result =
            calculator.calculateDamage(actor, target, game);

        this.damageDealt = result.totalDamage();
        target.takeDamage(result.totalDamage());
        actor.incrementActionsThisTurn();
        actor.startAttacking();

        game.notifyObservers(
            new UnitAttackedEvent(actor, target, result));

        if (!target.isAlive()) {
            game.handleUnitDeath(target);
        }
        this.wasExecuted = true;
    }

    @Override
    public void undo(Game game) {
        if (!wasExecuted) {
            throw new IllegalStateException(
                "Cannot undo command that wasn't executed");
        }
        int healthToRestore =
            targetPreviousHealth - target.getCurrentHealth();
        if (healthToRestore > 0) {
            target.heal(healthToRestore);
        }
        actor.decrementActionsThisTurn();
    }
}
\end{lstlisting}

Listing~\ref{lst:attack-command} zeigt den \texttt{AttackCommand}.
\texttt{execute()} sichert \texttt{targetPreviousHealth}, berechnet den Schaden über den \texttt{DamageCalculator} (Chain of Responsibility) und benachrichtigt die Observer per \texttt{UnitAttackedEvent}.
\texttt{undo()} heilt das Ziel um die Differenz und dekrementiert den Aktionszähler.

\subsection{Benutzeroberfläche (Christian Stiens)}
\label{sec:ui}

% - ASCII-Darstellung des Spielfelds
% - Eingabe-Aktionen: [B]ewegen, [A]ngreifen, [U]ndo, [R]edo, [Z]ug beenden
% - Ggf. Screenshot
% - Pattern-Bezug: Observer
Das 10$\times$10-Spielfeld wird als ASCII-Raster in der Konsole gerendert (Anforderung F6, vgl. Tabelle~\ref{tab:funktionale-anforderungen}).
Eine grafische Oberfläche hätte den zeitlichen Rahmen des Projektes gesprengt; die Konsolenausgabe ist vollständig funktional und zeigt alle spielrelevanten Informationen.

\begin{lstlisting}[language=Java, caption={Observer Pattern -- ConsoleGameRenderer.onEvent() und GameController}, label={lst:observer-ui}]
// ConsoleGameRenderer.java -- Concrete Observer
public class ConsoleGameRenderer
        implements GameRenderer, GameObserver {

    @Override
    public void onEvent(GameEvent event) {
        switch (event.getEventType()) {
            case UNIT_MOVED    -> handleUnitMoved(
                                    (UnitMovedEvent) event);
            case UNIT_ATTACKED -> handleUnitAttacked(
                                    (UnitAttackedEvent) event);
            case UNIT_DIED     -> handleUnitDeath(
                                    (UnitDeathEvent) event);
            case TERRAIN_CHANGED -> handleTerrainChanged(
                                    (TerrainChangedEvent) event);
            case TURN_STARTED,
                 TURN_ENDED    -> { /* Separator-Ausgabe */ }
            case GAME_OVER     -> handleGameOver(
                                    (GameOverEvent) event);
            default            -> { }
        }
    }

    private void handleUnitAttacked(UnitAttackedEvent event) {
        DamageResult r = event.getDamageResult();
        System.out.println("[Attack] " + event.getDescription());
        System.out.println("  Base: " + r.baseDamage()
            + ", Faction: x" + r.factionMultiplier()
            + ", Terrain: +"  + r.terrainAttackBonus()
            + ", Synergy: +"  + r.synergyBonus()
            + ", Defense: -"  + r.totalDefense()
            + " = "           + r.totalDamage() + " total");
    }
}

// GameController.java -- Observer-Registrierung
public GameController(Game game) {
    this.renderer = new ConsoleGameRenderer();
    this.eventLog = new EventLogObserver();
    game.addObserver((ConsoleGameRenderer) renderer);
    game.addObserver(eventLog);            // 2. Observer
}
\end{lstlisting}

Listing~\ref{lst:observer-ui} zeigt die Observer-Kopplung zwischen Spiellogik und Darstellung.
\texttt{ConsoleGameRenderer} implementiert gleichzeitig \texttt{GameRenderer} (für den direkten \texttt{render(game)}-Aufruf nach jeder Eingabe) und \texttt{GameObserver} (für ereignisgetriebene Ausgaben während der Ausführung).
In \texttt{onEvent()} werden alle acht \texttt{EventType}-Werte per \texttt{switch} auf private Handler-Methoden verteilt; \texttt{handleUnitAttacked()} gibt dabei die vollständige Schadensaufschlüsselung aus dem \texttt{DamageResult}-Record aus, das die Chain of Responsibility befüllt hat.
Im \texttt{GameController}-Konstruktor werden beide Observer per \texttt{game.addObserver()} registriert: \texttt{ConsoleGameRenderer} für die Echtzeit-Konsolenausgabe und \texttt{EventLogObserver} zum Aufzeichnen aller Ereignisse.
Der \texttt{GameController} liest Spielereingaben über \texttt{ConsoleUI} aus und verteilt sie per \texttt{switch} auf die entsprechenden Command-Objekte (\texttt{MoveCommand}, \texttt{AttackCommand}), die über \texttt{game.executeCommand()} ausgeführt und in der \texttt{CommandHistory} protokolliert werden (vgl. \texttt{GameController.java Z.\,63ff}).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/UI}
    \caption{Beispielhafte Konsolenausgabe eines Spielfeldes}
    \label{fig:ui}
\end{figure}



