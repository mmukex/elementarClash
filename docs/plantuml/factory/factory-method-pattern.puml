@startuml Factory Method Pattern - ElementarClash

!define ABSTRACT_CLASS abstract class
!define INTERFACE interface

skinparam classAttributeIconSize 0
skinparam shadowing false
skinparam class {
    BackgroundColor<<Abstract>> LightYellow
    BorderColor<<Abstract>> DarkOrange
    BackgroundColor<<Concrete>> LightBlue
    BorderColor<<Concrete>> DarkBlue
}

enum Faction {
    FIRE
    WATER
    EARTH
    AIR
}

' ===== Creator (Abstract Factory) =====
ABSTRACT_CLASS UnitFactory <<Abstract>> {
    - faction: Faction
    - unitCounter: int
    __
    # UnitFactory(faction: Faction)
    __
    + {final} createUnit(type: UnitType): Unit
    # {abstract} createUnitInternal(id: String, type: UnitType): Unit
    # {abstract} isValidTypeForFaction(type: UnitType): boolean
    - generateUnitId(type: UnitType): String
    + getFaction(): Faction
}

' ===== Product (Abstract Product) =====
ABSTRACT_CLASS Unit <<Abstract>> {
    - id: String
    - name: String
    - faction: Faction
    - type: UnitType
    - baseStats: UnitStats
    - currentHealth: int
    - position: Position
    - acted: boolean
    __
    # Unit(id, name, faction, type, stats)
    __
    + isAlive(): boolean
    + takeDamage(damage: int): void
    + heal(amount: int): void
    + resetTurn(): void
    + markAsActed(): void
    + {abstract} getSpecialAbility(): String
    + getTerrainAttackBonus(): int
    + getTerrainDefenseBonus(): int
}

' ===== Enum =====
enum UnitType {
    INFERNO_WARRIOR
    FLAME_ARCHER
    PHOENIX
    TIDE_GUARDIAN
    FROST_MAGE
    WAVE_RIDER
    STONE_GOLEM
    TERRA_SHAMAN
    EARTHQUAKE_TITAN
    WIND_DANCER
    STORM_CALLER
    SKY_GUARDIAN
}

class UnitStats {
    + maxHealth: int
    + attack: int
    + defense: int
    + movement: int
    + range: int
}

' ===== Concrete Factory =====
class FireUnitFactory <<Concrete>> {
    + FireUnitFactory()
    __
    # createUnitInternal(id: String, type: UnitType): Unit
    # isValidTypeForFaction(type: UnitType): boolean
}

' ===== Concrete Units (package-private) =====
class InfernoWarrior <<Concrete>> <<package-private>> {
    - {static} LAVA_ATTACK_BONUS: int = 2
    __
    ~ InfernoWarrior(id: String, stats: UnitStats)
    + getSpecialAbility(): String
    + getTerrainAttackBonus(): int
}

' ===== Inheritance Relationships =====
UnitFactory <|-- FireUnitFactory

Unit <|-- InfernoWarrior

' ===== Dependencies =====
UnitFactory ..> Unit : <<creates>>
FireUnitFactory ..> InfernoWarrior : <<creates>>

UnitFactory ..> UnitType : <<uses>>
UnitFactory o-- Faction
Unit o-- UnitStats
Unit ..> Faction : <<uses>>
Unit ..> UnitType : <<uses>>

' ===== Notes =====
note right of UnitFactory
  **Factory Method Pattern**

  Template Method: createUnit()
  - Validates unit type
  - Generates unique ID
  - Delegates to factory method

  Factory Method: createUnitInternal()
  - Implemented by concrete factories
  - Creates faction-specific units
end note

note bottom of Unit
  **Unit Hierarchy**

  Abstract unit with:
  - Common attributes & behavior
  - Abstract factory method
  - Hook methods for subclasses
end note

note bottom of InfernoWarrior
  **Package Structure & Encapsulation**

  All concrete Unit classes are package-private.
  They can ONLY be instantiated via their Factory.

  Package organization:
  • org.elementarclash.units - Abstract classes & enums
  • org.elementarclash.units.fire - FireUnitFactory + 3 units
  • org.elementarclash.units.water - WaterUnitFactory + 3 units
  • org.elementarclash.units.air - AirUnitFactory + 3 units
  • org.elementarclash.units.earth - EarthUnitFactory + 3 units

  Each faction package contains:
  - 1 public Factory (FireUnitFactory, WaterUnitFactory, ...)
  - 3 package-private Units (InfernoWarrior, FlameArcher, Phoenix, ...)

  (Diagram shows fire faction as example)
end note


@enduml
