@startuml Decorator Pattern - ElementarClash

!define ABSTRACT_CLASS abstract class
!define INTERFACE interface

skinparam classAttributeIconSize 0
skinparam shadowing false
skinparam class {
    BackgroundColor<<Abstract>> LightYellow
    BorderColor<<Abstract>> DarkOrange
    BackgroundColor<<Concrete>> LightBlue
    BorderColor<<Concrete>> DarkBlue
    BackgroundColor<<Temporary>> LightGreen
    BorderColor<<Temporary>> DarkGreen
    BackgroundColor<<Manager>> Wheat
    BorderColor<<Manager>> Brown
}

title Decorator Pattern - ElementarClash Unit Buffs/Debuffs\nGoF #4: Dynamically Attaching Responsibilities

package "org.elementarclash.units.bonus" {

    ' ===== Abstract Decorator =====
    ABSTRACT_CLASS UnitDecorator <<Abstract>> {
        + {abstract} getAttackBonus(unit: Unit): int
        + {abstract} getDefenseBonus(unit: Unit): int
        + {abstract} getMovementBonus(unit: Unit): int
        + {abstract} isExpired(): boolean
        + {abstract} tick(): void
        + {abstract} getDecoratorName(): String
        + {abstract} getDescription(): String
    }

    ' ===== Permanent Decorator =====
    class SynergyBonus <<Concrete>> {
        - game: Game
        - faction: Faction
        __
        + SynergyBonus(game: Game, faction: Faction)
        __
        + getAttackBonus(unit: Unit): int
        + getDefenseBonus(unit: Unit): int
        + getMovementBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDecoratorName(): String
        + getDescription(): String
    }

    ' ===== Buff/Debuff Manager =====
    class BuffDebuffManager <<Manager>> {
        - {static} RANDOM: Random
        - {static} BASE_CHANCE: double = 0.03
        - {static} INCREASE_PER_ROUND: double = 0.06
        - {static} MAX_CHANCE: double = 0.60
        - {static} BUFF_POOL: List<Supplier<UnitDecorator>>
        - {static} DEBUFF_POOL: List<Supplier<UnitDecorator>>
        __
        + tryApplyRandomEffect(game: Game, currentRound: int): void
        - calculateChance(currentRound: int): double
    }
}

package "org.elementarclash.units.bonus.temporary" {

    ' ===== Temporary Buff Decorators =====
    class AttackBuffDecorator <<Temporary>> {
        - {static} BONUS: int = 2
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getAttackBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }

    class AttackDebuffDecorator <<Temporary>> {
        - {static} BONUS: int = -2
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getAttackBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }

    class DefenseBuffDecorator <<Temporary>> {
        - {static} BONUS: int = 2
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getDefenseBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }

    class DefenseDebuffDecorator <<Temporary>> {
        - {static} BONUS: int = -2
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getDefenseBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }

    class HastenedDecorator <<Temporary>> {
        - {static} MOVEMENT_PENALTY: int = -1
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getMovementBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }

    class SlowedDecorator <<Temporary>> {
        - {static} MOVEMENT_PENALTY: int = -1
        - {static} DURATION: int = 2
        - remainingRounds: int
        __
        + getMovementBonus(unit: Unit): int
        + isExpired(): boolean
        + tick(): void
        + getDescription(): String
    }
}

package "org.elementarclash.units" {

    ' ===== Component (decorated class) =====
    ABSTRACT_CLASS Unit <<Abstract>> {
        - decorators: List<UnitDecorator>
        __
        + addDecorator(decorator: UnitDecorator): void
        + removeDecorator(decorator: UnitDecorator): void
        + removeDecoratorsOfType(clazz: Class): void
        + removeExpiredDecorators(): void
        + getDecorators(): List<UnitDecorator>
        __
        + getAttack(): int
        + getDefense(): int
        + getMovement(): int
    }
}

' ===== Inheritance =====
UnitDecorator <|-- SynergyBonus
UnitDecorator <|-- AttackBuffDecorator
UnitDecorator <|-- AttackDebuffDecorator
UnitDecorator <|-- DefenseBuffDecorator
UnitDecorator <|-- DefenseDebuffDecorator
UnitDecorator <|-- HastenedDecorator
UnitDecorator <|-- SlowedDecorator

' ===== Associations =====
Unit o-right-> "0..*" UnitDecorator : decorators
BuffDebuffManager ..> UnitDecorator : <<creates>>
BuffDebuffManager ..> Unit : <<modifies>>
SynergyBonus ..> Unit : <<reads adjacency>>

' ===== Notes =====
note right of UnitDecorator
  **Decorator Pattern (GoF #4)**

  **Purpose:**
  Dynamically attach stat bonuses/penalties
  to units without modifying the Unit class.

  **Bonus Types:**
  - Attack (ATK +/- N)
  - Defense (DEF +/- N)
  - Movement (MOV +/- N)

  **Lifecycle:**
  1. Created by BuffDebuffManager or Game
  2. Added via unit.addDecorator()
  3. Ticked at end of turn (tick())
  4. Removed when expired (removeExpiredDecorators())

  **Key Benefit:**
  Multiple decorators stack transparently.
  Unit.getAttack() sums base + all decorator bonuses.
end note

note bottom of SynergyBonus
  **Permanent / Dynamic Decorator**

  Never expires (isExpired() = false).
  Bonus recalculated dynamically:

  **Fire Faction:**
  +1 ATK per adjacent allied unit.

  **Recalculation:**
  On unit movement, old SynergyBonus
  is removed and new one is added:
    unit.removeDecoratorsOfType(SynergyBonus.class)
    unit.addDecorator(new SynergyBonus(game, faction))
end note

note bottom of BuffDebuffManager
  **Random Buff/Debuff Application**

  Called at start of each PlayerTurnPhase.

  **Probability Formula:**
  chance = BASE_CHANCE + (round-1) * INCREASE_PER_ROUND
  capped at MAX_CHANCE (60%)

  **Round 1:** 3%
  **Round 5:** 27%
  **Round 10:** 57%
  **Round 11+:** 60% (cap)

  **Selection:**
  1. Roll chance
  2. Pick random alive unit of active faction
  3. 50/50 buff vs debuff
  4. Random effect from pool
end note

note top of Unit
  **Component (Decorated Object)**

  **Stat Calculation with Decorators:**

  public int getAttack() {
      int attack = baseStats.attack();
      for (UnitDecorator d : decorators) {
          if (!d.isExpired())
              attack += d.getAttackBonus(this);
      }
      return attack;
  }

  Same pattern for getDefense() and getMovement().
  Movement has minimum of 1: Math.max(1, movement)
end note

note as TemporaryNote
  **Temporary Decorators**

  All temporary decorators share:
  - Fixed duration: 2 rounds
  - Countdown via tick()
  - Expired when remainingRounds <= 0

  **Buff Pool:** ATK+2, DEF+2, MOV-1 (Hastened)
  **Debuff Pool:** ATK-2, DEF-2, MOV-1 (Slowed)

  **Description format (UI):**
  "+2 Attack (2 rounds left)"
  "-2 Defense (1 rounds left)"
  "Movement -1 (2 rounds left)"
end note

@enduml
