@startuml Chain of Responsibility Pattern - ElementarClash

!define ABSTRACT_CLASS abstract class
!define INTERFACE interface

skinparam classAttributeIconSize 0
skinparam shadowing false
skinparam class {
    BackgroundColor<<Handler>> LightYellow
    BorderColor<<Handler>> DarkOrange
    BackgroundColor<<ConcreteHandler>> LightBlue
    BorderColor<<ConcreteHandler>> DarkBlue
    BackgroundColor<<Context>> LightGreen
    BorderColor<<Context>> DarkGreen
    BackgroundColor<<ValueObject>> Wheat
    BorderColor<<ValueObject>> Brown
}

title Chain of Responsibility Pattern - ElementarClash Damage Pipeline\nGoF #9: Decoupled Request Processing Through Handler Chain

' ===== Abstract Handler =====
ABSTRACT_CLASS DamageHandler <<Handler>> {
    - next: DamageHandler
    __
    + setNext(next: DamageHandler): DamageHandler
    + handle(context: DamageContext): void
}

' ===== Concrete Handlers =====
class BaseDamageHandler <<ConcreteHandler>> {
    + handle(context: DamageContext): void
}

class FactionAdvantageHandler <<ConcreteHandler>> {
    - {static} ADVANTAGE_MATRIX: Map<Faction, Map<Faction, Double>>
    __
    + handle(context: DamageContext): void
}

class TerrainEffectHandler <<ConcreteHandler>> {
    + handle(context: DamageContext): void
}

class SynergyBonusHandler <<ConcreteHandler>> {
    + handle(context: DamageContext): void
}

class DefenseCalculationHandler <<ConcreteHandler>> {
    + handle(context: DamageContext): void
}

' ===== Chain Builder / Client =====
class DamageCalculator <<Context>> {
    - handlerChain: DamageHandler
    __
    + DamageCalculator()
    + calculateDamage(attacker: Unit, target: Unit, game: Game): DamageResult
}

' ===== Shared State =====
class DamageContext <<Context>> {
    - attacker: Unit
    - target: Unit
    - game: Game
    - calculationSteps: List<String>
    __
    - baseDamage: int = 0
    - factionMultiplier: double = 1.0
    - terrainAttackBonus: int = 0
    - terrainDefenseBonus: int = 0
    - synergyBonus: int = 0
    - totalDefense: int = 0
    - finalDamage: int = 0
    __
    + DamageContext(attacker, target, game)
    + setBaseDamage(baseDamage: int): void
    + applyFactionMultiplier(multiplier: double): void
    + addTerrainAttackBonus(bonus: int): void
    + addTerrainDefenseBonus(bonus: int): void
    + addSynergyBonus(bonus: int): void
    + setTotalDefense(defense: int): void
    + setFinalDamage(damage: int): void
    + getTotalAttack(): int
    + toResult(): DamageResult
}

' ===== Immutable Result =====
class "DamageResult\n<<record>>" as DamageResult <<ValueObject>> {
    + totalDamage: int
    + baseDamage: int
    + factionMultiplier: double
    + terrainAttackBonus: int
    + terrainDefenseBonus: int
    + synergyBonus: int
    + totalDefense: int
    + calculationSteps: List<String>
}

' ===== Chain Inheritance =====
DamageHandler <|-- BaseDamageHandler
DamageHandler <|-- FactionAdvantageHandler
DamageHandler <|-- TerrainEffectHandler
DamageHandler <|-- SynergyBonusHandler
DamageHandler <|-- DefenseCalculationHandler

' ===== Chain Links =====
DamageHandler o-right-> DamageHandler : next

' ===== Associations =====
DamageCalculator *-down-> DamageHandler : handlerChain
DamageCalculator ..> DamageContext : <<creates>>
DamageContext ..> DamageResult : toResult()
DamageHandler ..> DamageContext : <<modifies>>

' ===== Notes =====
note right of DamageHandler
  **Chain of Responsibility (GoF #9)**

  **Purpose:**
  Modular damage calculation pipeline.
  Each handler processes one aspect,
  then passes to the next.

  **Fluent Chain Construction:**
  handlerChain
    .setNext(handler2)
    .setNext(handler3)
    ...

  **Template:**
  Subclasses add their logic, then
  call super.handle(context) to
  pass to next handler in chain.
  Null-safe termination at end.
end note

note bottom of BaseDamageHandler
  **Handler #1: Base Damage**

  **Integration: Strategy Pattern**

  int baseDamage = attacker
    .getAttackStrategy()
    .calculateBaseDamage(attacker, target);

  context.setBaseDamage(baseDamage);

  Uses AttackStrategy from the unit
  (MeleeAttackStrategy or RangedAttackStrategy).
end note

note bottom of FactionAdvantageHandler
  **Handler #2: Faction Multiplier**

  Applies rock-paper-scissors multipliers:

  | Attacker | Defender | Multiplier |
  |----------|----------|------------|
  | Fire     | Earth    | x1.25      |
  | Fire     | Water    | x0.75      |
  | Water    | Fire     | x1.25      |
  | Water    | Earth    | x0.75      |
  | Earth    | Water    | x1.25      |
  | Earth    | Air      | x0.75      |
  | Air      | Earth    | x1.25      |
  | Air      | Fire     | x0.75      |

  Neutral matchups: x1.0 (no change)
end note

note bottom of TerrainEffectHandler
  **Handler #3: Terrain Effects**

  **Integration: Visitor Pattern**

  Applies bonuses for both sides:

  **Attacker's terrain:**
  visitor = TerrainVisitorFactory.getVisitor(terrain)
  effect = attacker.accept(visitor)
  -> adds attackBonus (e.g. Fire on Lava: +2)

  **Defender's terrain:**
  visitor = TerrainVisitorFactory.getVisitor(terrain)
  effect = target.accept(visitor)
  -> adds defenseBonus (e.g. Forest: +2)
end note

note bottom of SynergyBonusHandler
  **Handler #4: Synergy & Decorator Bonuses**

  **Integration: Decorator Pattern**

  Sums attack bonuses from all active decorators:

  int synergyBonus = attacker.getDecorators()
    .stream()
    .filter(d -> !d.isExpired())
    .mapToInt(d -> d.getAttackBonus(attacker))
    .sum();

  Includes: SynergyBonus, AttackBuffDecorator,
  AttackDebuffDecorator, etc.
end note

note bottom of DefenseCalculationHandler
  **Handler #5: Final Calculation (Terminal)**

  **Formula:**
  totalAttack = base + terrainATK + synergy
  totalDefense = target.getDefense()
    (includes decorator DEF bonuses)
  finalDamage = max(1, totalAttack - totalDefense)

  **Minimum Damage:** Always at least 1.
  Ensures every attack has some effect.
end note

note left of DamageCalculator
  **Chain Construction (Order Matters!)**

  public DamageCalculator() {
      handlerChain = new BaseDamageHandler();
      handlerChain
        .setNext(new FactionAdvantageHandler())
        .setNext(new TerrainEffectHandler())
        .setNext(new SynergyBonusHandler())
        .setNext(new DefenseCalculationHandler());
  }

  **Usage (from AttackCommand):**
  DamageCalculator calc = new DamageCalculator();
  DamageResult result =
      calc.calculateDamage(attacker, target, game);
  target.takeDamage(result.totalDamage());

  **Extensibility:**
  Adding new modifier (e.g. WeatherEffectHandler)
  = insert one new handler in chain.
  No existing code changes needed.
end note

note right of DamageContext
  **Shared Mutable State**

  Passed through the entire chain.
  Each handler reads/writes relevant fields.

  **Automatic Logging:**
  Each setter logs a calculation step:
  "Base Damage: 15"
  "Faction Advantage: x1.25 (15 -> 19)"
  "Terrain Attack Bonus: +2"

  **getTotalAttack():**
  Returns baseDamage + terrainAttackBonus
  + synergyBonus
end note

note as PipelineFlow
  **Damage Calculation Pipeline**

  BaseDamageHandler
       | baseDamage = attackStrategy.calculate()
       v
  FactionAdvantageHandler
       | baseDamage *= factionMultiplier
       v
  TerrainEffectHandler
       | + terrainAttackBonus (attacker terrain)
       | + terrainDefenseBonus (defender terrain)
       v
  SynergyBonusHandler
       | + synergyBonus (all decorator ATK bonuses)
       v
  DefenseCalculationHandler
       | totalAttack = base + terrain + synergy
       | finalDamage = max(1, totalAttack - defense)
       v
  DamageResult (immutable)

  **Example:** Fire unit on Lava attacks Water unit
  Base: 15 -> Faction: x0.75 = 11 -> Terrain: +2
  -> Synergy: +1 -> Total ATK: 14 - DEF: 8 = 6
end note

@enduml
